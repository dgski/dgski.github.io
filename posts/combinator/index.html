
    <!doctype html>
    <html>
        <head>
            <title> The Fixed-Point Combinator Function</title>
            <link rel="stylesheet" type="text/css" href="/style.css">
        </head>
        <body>
            <div class="post-content">
                <h1 class="post-title"> The Fixed-Point Combinator Function</h1>
                <em> Implementing Functional Recursion as a Non-Primitive Feature</em>
                <div class="post-body">
                    <blank><p>The goal of this article is to explain the purpose and functionality of <b>fixed-point combinator functions</b>. I had a hard time following along with other articles on this topic so I wrote this as a learning exercise. We'll be using the <b>Scheme</b> language.</p><p>So what is a <b>fixed-point combinator</b>? It is a function which given a function as an argument, returns a fixed point of that function. Let's demonstrate why this could be useful.</p><p>First, let start by defining a factorial function recursively:</p><div class='code' >(define&nbsp;fact&nbsp;<br>&nbsp;&nbsp;(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(fact&nbsp;(-&nbsp;n&nbsp;1))))))<br></div><p>Theoretically, if our language suddenly loses recursion as a feature we run into a big problem; we can't refer to a function that is not bound! There is no 'self' keyword inside a anonymous function (which would let us reference the function from within) and therefore the function will no longer be valid:</p><div class='code' >(lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))<br></div><p>To clarify, the function is actually valid, but only for an input of <b>0</b>:</p><div class='code' >;&nbsp;0&nbsp;-&gt;&nbsp;1<br><br>((lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;0)<br></div><p>But if we try with any other value, it will fail:</p><div class='code' >;&nbsp;1&nbsp;-&gt;&nbsp;error:&nbsp;unbound&nbsp;symbol&nbsp;(???)<br><br>((lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;1)<br></div><p>An input of <b>1</b> does not fulfill the first condition <b>(zero?)</b>, so it attempts to call <b>???</b> with <b>(- n 1)</b> as it's argument. <b>???</b> is a symbol not bound to anything so an error is raised. However, we do know that for the current call the expression <b>(- n 1)</b> is equal to <b>0</b>, since <b>n</b> is bound to <b>1</b>. We know this function works for zero, so we know we can simply substitute it in for <b>???</b>. Now we have a function that works for two inputs: 0 and 1:</p><div class='code' >((lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;((lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;1)<br></div><p>Using the former logic we can continue this process, replacing <b>???</b> with our 'factorial' lambda; creating a function that can work with another successive input. This could get tedious, so let's write a function that does that for us.</p><div class='code' >(define&nbsp;fact-gen<br>&nbsp;&nbsp;(lambda&nbsp;(f)<br>&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(f&nbsp;(-&nbsp;n&nbsp;1)))))))<br></div><p>By itself, the return value is our <b>fact0</b> function, which we used unbound earlier, Since an input of 0 doesnt call the <b>f</b> function, we can pass anything we'd like.</p><div class='code' >(define&nbsp;fact0&nbsp;(fact-gen&nbsp;'trash))<br>&nbsp;-&gt;&nbsp;(lambda&nbsp;(next)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;('trash&nbsp;(-&nbsp;n&nbsp;1))))))<br><br>(fact0&nbsp;0)&nbsp;-&gt;&nbsp;1<br></div><p>However, due to the conditional statement, if input is greater than <b>0</b>, the argument will be called, and that's simply impossible as it is currently is just  a <b>'trash</b> symbol.</p><div class='code' >(fact0&nbsp;1)&nbsp;-&gt;&nbsp;ERROR<br></div><p>We need to supply a function that will give us the factorial of <b>(- 1 1)</b>. Wait a second... That expression equals <b>0</b>... We already have a function that gives us the factorial of <b>0</b>... Let's run <b>fact-gen</b> and pass it <b>fact0</b>.</p><div class='code' >(define&nbsp;fact&lt;=1&nbsp;(fact-gen&nbsp;fact0))<br></div><p>Using this newly generated function, we can find the factorial of any number equal or less than one. Can we continue? In fact, yes!</p><div class='code' >(define&nbsp;fact&lt;=2&nbsp;(fact-gen&nbsp;fact&lt;=1))<br></div><p>Now the next step is clear. We need to supply the consecutive factorial function to the previous factorial function n + 1 times (starting at 0). How can we continually feed the <b>fact-gen</b> function these next factorial functions? Turns out that a combinator function can do that for us:</p><div class='code' >(define&nbsp;combinator<br>&nbsp;&nbsp;(lambda&nbsp;(func)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;make-step<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(next-step)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(arg)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((func&nbsp;(next-step&nbsp;next-step))&nbsp;arg))))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(arg)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((func&nbsp;(make-step&nbsp;make-step))&nbsp;arg))))<br></div><p>Notice that the returned lambda at the end of <b>combinator</b> function and the returned lambda for the locally scoped function <b>make-step</b>, are exactly the same. This is crucial. That means that when the generated factorial function needs the next factorial function, it simply inserts itself again. Let's walk through this. Running <b>(combinator fact-gen)</b> will return:</p><div class='code' >;&nbsp;figure-1<br>(lambda&nbsp;(arg)<br>&nbsp;&nbsp;((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg))<br></div><p>When this function is called with any argument it will first resolve the expression <b>(make-step make-step)</b>. This function call will return the following:</p><div class='code' >;&nbsp;figure-2<br>(lambda&nbsp;(arg)<br>&nbsp;&nbsp;((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg))<br></div><p>Does this look familiar? Its the same as before! This is the fixed point. As seen in <b>figure-1</b>, this lambda (figure-2) will serve as the argument for the <b>(fact-gen figure-2)</b> function call, which returns:</p><div class='code' >;&nbsp;figure-3<br>(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(figure-2&nbsp;(-&nbsp;n&nbsp;1)))))<br></div><p>Let's call it with the argument of number '1': <b>(figure-3 1)</b>. Since 1 is not <b>zero?</b> the control flow will evaluate the next expression: <b>(* 1 (figure-2 (- 1 1)))</b>. Which includes the function call <b>(figure-2 (- 1 1))</b>. This will return the following:</p><div class='code' >((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg)<br></div><p><b>(make-step make-step)</b> will again return:</p><div class='code' >;&nbsp;figure-4<br>(lambda&nbsp;(arg)<br>&nbsp;&nbsp;((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg))<br></div><p>and the whole <b>figure-2</b> call will evaluate to:</p><div class='code' >;&nbsp;figure-5<br>(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(figure-4&nbsp;(-&nbsp;n&nbsp;1)))))<br></div><p>Just to clarify, we are currently evaluating <b>(* 1 (figure-2 (- 1 1)))</b>. <b>n</b> is bound to <b>0</b> in <b>figure-5</b>, so the <b>if</b> expression returns 1. Therefore everything resolves to:</p><div class='code' >(*&nbsp;1&nbsp;1)&nbsp;-&gt;&nbsp;1<br></div><p>And that's pretty much it. We can simplify the whole thing by eliminating our locale definition of <b>make-step</b> and replacing our readable variables with single letters:</p><div class='code' >(define&nbsp;Z<br>&nbsp;&nbsp;(lambda&nbsp;(f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((f&nbsp;((lambda&nbsp;(y)&nbsp;(lambda&nbsp;(a)&nbsp;((f&nbsp;(y&nbsp;y))&nbsp;a)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)&nbsp;(lambda&nbsp;(a)&nbsp;((f&nbsp;(y&nbsp;y))&nbsp;a)))))&nbsp;a))))<br></div></blank>
                </div>
                <strong>Post By <a href="/"> David Gorski</a> on 2019/05/12 00:00:00</strong>
            </div>
        </body>
    </html>
