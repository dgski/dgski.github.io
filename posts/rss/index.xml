<?xml version='1.0' encoding='UTF-8' ?><rss version='2.0' ><channel><title> David Gorski</title><item><title> The Fixed-Point Combinator Function</title><link> https://davidgorski.ca/posts/combinator/index.html</link><description> Implementing Functional Recursion as a Non-Primitive Feature</description><content type='html' ><blank><p>The goal of this article is to explain the purpose and functionality of <b>fixed-point combinator functions</b>. I had a hard time following along with other articles on this topic so I wrote this as a learning exercise. We'll be using the <b>Scheme</b> language.</p><p>So what is a <b>fixed-point combinator</b>? It is a function which given a function as an argument, returns a fixed point of that function. Let's demonstrate why this could be useful.</p><p>First, let start by defining a factorial function recursively:</p><div class='code' >(define&nbsp;fact&nbsp;<br>&nbsp;&nbsp;(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(fact&nbsp;(-&nbsp;n&nbsp;1))))))<br></div><p>Theoretically, if our language suddenly loses recursion as a feature we run into a big problem; we can't refer to a function that is not bound! There is no 'self' keyword inside a anonymous function (which would let us reference the function from within) and therefore the function will no longer be valid:</p><div class='code' >(lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))<br></div><p>To clarify, the function is actually valid, but only for an input of <b>0</b>:</p><div class='code' >;&nbsp;0&nbsp;-&gt;&nbsp;1<br><br>((lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;0)<br></div><p>But if we try with any other value, it will fail:</p><div class='code' >;&nbsp;1&nbsp;-&gt;&nbsp;error:&nbsp;unbound&nbsp;symbol&nbsp;(???)<br><br>((lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;1)<br></div><p>An input of <b>1</b> does not fulfill the first condition <b>(zero?)</b>, so it attempts to call <b>???</b> with <b>(- n 1)</b> as it's argument. <b>???</b> is a symbol not bound to anything so an error is raised. However, we do know that for the current call the expression <b>(- n 1)</b> is equal to <b>0</b>, since <b>n</b> is bound to <b>1</b>. We know this function works for zero, so we know we can simply substitute it in for <b>???</b>. Now we have a function that works for two inputs: 0 and 1:</p><div class='code' >((lambda&nbsp;(n)<br>&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;((lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(???&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;(-&nbsp;n&nbsp;1)))))&nbsp;1)<br></div><p>Using the former logic we can continue this process, replacing <b>???</b> with our 'factorial' lambda; creating a function that can work with another successive input. This could get tedious, so let's write a function that does that for us.</p><div class='code' >(define&nbsp;fact-gen<br>&nbsp;&nbsp;(lambda&nbsp;(f)<br>&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(f&nbsp;(-&nbsp;n&nbsp;1)))))))<br></div><p>By itself, the return value is our <b>fact0</b> function, which we used unbound earlier, Since an input of 0 doesnt call the <b>f</b> function, we can pass anything we'd like.</p><div class='code' >(define&nbsp;fact0&nbsp;(fact-gen&nbsp;'trash))<br>&nbsp;-&gt;&nbsp;(lambda&nbsp;(next)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;('trash&nbsp;(-&nbsp;n&nbsp;1))))))<br><br>(fact0&nbsp;0)&nbsp;-&gt;&nbsp;1<br></div><p>However, due to the conditional statement, if input is greater than <b>0</b>, the argument will be called, and that's simply impossible as it is currently is just  a <b>'trash</b> symbol.</p><div class='code' >(fact0&nbsp;1)&nbsp;-&gt;&nbsp;ERROR<br></div><p>We need to supply a function that will give us the factorial of <b>(- 1 1)</b>. Wait a second... That expression equals <b>0</b>... We already have a function that gives us the factorial of <b>0</b>... Let's run <b>fact-gen</b> and pass it <b>fact0</b>.</p><div class='code' >(define&nbsp;fact&lt;=1&nbsp;(fact-gen&nbsp;fact0))<br></div><p>Using this newly generated function, we can find the factorial of any number equal or less than one. Can we continue? In fact, yes!</p><div class='code' >(define&nbsp;fact&lt;=2&nbsp;(fact-gen&nbsp;fact&lt;=1))<br></div><p>Now the next step is clear. We need to supply the consecutive factorial function to the previous factorial function n + 1 times (starting at 0). How can we continually feed the <b>fact-gen</b> function these next factorial functions? Turns out that a combinator function can do that for us:</p><div class='code' >(define&nbsp;combinator<br>&nbsp;&nbsp;(lambda&nbsp;(func)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;make-step<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(next-step)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(arg)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((func&nbsp;(next-step&nbsp;next-step))&nbsp;arg))))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(arg)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((func&nbsp;(make-step&nbsp;make-step))&nbsp;arg))))<br></div><p>Notice that the returned lambda at the end of <b>combinator</b> function and the returned lambda for the locally scoped function <b>make-step</b>, are exactly the same. This is crucial. That means that when the generated factorial function needs the next factorial function, it simply inserts itself again. Let's walk through this. Running <b>(combinator fact-gen)</b> will return:</p><div class='code' >;&nbsp;figure-1<br>(lambda&nbsp;(arg)<br>&nbsp;&nbsp;((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg))<br></div><p>When this function is called with any argument it will first resolve the expression <b>(make-step make-step)</b>. This function call will return the following:</p><div class='code' >;&nbsp;figure-2<br>(lambda&nbsp;(arg)<br>&nbsp;&nbsp;((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg))<br></div><p>Does this look familiar? Its the same as before! This is the fixed point. As seen in <b>figure-1</b>, this lambda (figure-2) will serve as the argument for the <b>(fact-gen figure-2)</b> function call, which returns:</p><div class='code' >;&nbsp;figure-3<br>(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(figure-2&nbsp;(-&nbsp;n&nbsp;1)))))<br></div><p>Let's call it with the argument of number '1': <b>(figure-3 1)</b>. Since 1 is not <b>zero?</b> the control flow will evaluate the next expression: <b>(* 1 (figure-2 (- 1 1)))</b>. Which includes the function call <b>(figure-2 (- 1 1))</b>. This will return the following:</p><div class='code' >((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg)<br></div><p><b>(make-step make-step)</b> will again return:</p><div class='code' >;&nbsp;figure-4<br>(lambda&nbsp;(arg)<br>&nbsp;&nbsp;((fact-gen&nbsp;(make-step&nbsp;make-step))&nbsp;arg))<br></div><p>and the whole <b>figure-2</b> call will evaluate to:</p><div class='code' >;&nbsp;figure-5<br>(lambda&nbsp;(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(figure-4&nbsp;(-&nbsp;n&nbsp;1)))))<br></div><p>Just to clarify, we are currently evaluating <b>(* 1 (figure-2 (- 1 1)))</b>. <b>n</b> is bound to <b>0</b> in <b>figure-5</b>, so the <b>if</b> expression returns 1. Therefore everything resolves to:</p><div class='code' >(*&nbsp;1&nbsp;1)&nbsp;-&gt;&nbsp;1<br></div><p>And that's pretty much it. We can simplify the whole thing by eliminating our locale definition of <b>make-step</b> and replacing our readable variables with single letters:</p><div class='code' >(define&nbsp;Z<br>&nbsp;&nbsp;(lambda&nbsp;(f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((f&nbsp;((lambda&nbsp;(y)&nbsp;(lambda&nbsp;(a)&nbsp;((f&nbsp;(y&nbsp;y))&nbsp;a)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)&nbsp;(lambda&nbsp;(a)&nbsp;((f&nbsp;(y&nbsp;y))&nbsp;a)))))&nbsp;a))))<br></div></blank></content></item><item><title> Custom STL Compatible Iterators</title><link> https://davidgorski.ca/posts/stl-iterators/index.html</link><description> A Practical Start to Writing Simple Iteration Classes in C++</description><content type='html' ><blank><h2>What is an Iterator?</h2><p>The <b>Iterator</b> is the abstraction at the heart of all Collection-related functionality within the C++ Standard Library. Most algorithms are defined in terms of iterators. What is an iterator exactly?</p><p>Fundamentally, an Iterator represents a point of iteration. A point of iteration describes:</p><ul><li>How to retrieve the value at the point</li><li>How the point of iteration can be incremented/decremented</li><li>How to compare it with other points of iteration</li></ul><p>For example: Conceptually, if you are 'iterating' over a <b>book's pages</b>, the point of iteration could describe the following rules:</p><ul><li>The value at the point of iteration can be retrieved by reading the current page.</li><li>The point of iteration can be incremented by turning the page forward.</li><li>You can compare the point of iteration with other points of iteration by looking at the page number.</li></ul><p><i>Take note how this book example does not describe how to 'decrement' the iteration. Philosophically speaking, using this description; you could only ever turn the pages forward, never back.</i></p><p>In C++, iterators are defined as objects with methods describing their rules.</p><h2>Creating a Custom Collection</h2><p>First, we are going to create a custom collection type compatible with <b>STL algorithm constructs</b> and <b>ranged for-loops</b>. At that level of abstraction all we need to provide is <b>begin()</b> and <b>end()</b> methods, and then we will be able to write code like this:</p><div class='code' >Collection&nbsp;col;<br><br>for(auto&&nbsp;c&nbsp;:&nbsp;col)<br>&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;c&nbsp;&lt;&lt;&nbsp;endl;<br><br>std::transform(begin(col),&nbsp;end(col),&nbsp;begin(col),&nbsp;[](auto&&nbsp;i)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i&nbsp;*&nbsp;i;<br>});<br></div><p>Our collection will be a simple wrapper class around a c-array. This is what <b>std::array</b> provides in the Standard Library. In reality, you will only write custom collections and iterators if you need very particular data structures satisfying very specific requirements. Here is our collection definition:</p><div class='code' >template&lt;class&nbsp;T,&nbsp;int&nbsp;N&gt;<br>class&nbsp;Collection<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;data[N]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&nbsp;begin()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_iterator&lt;T&gt;(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&nbsp;end()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_iterator&lt;T&gt;(data&nbsp;+&nbsp;N);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br></div><p>We take type and size as template arguments, create an array of that type and size. We also define methods which return the iterators to the beginning and end of the collection, passing the pointers to the first element (data) and just past the last element (data + N) as arguments.</p><h2>The Iterator Itself</h2><p>Now that we have created a collection-type, we need to define the iterator for use with the <b>begin()</b> and <b>end()</b> methods. First, we declare our iterator class ahead of our collection class declaration (The class needs to be aware of the iterator's existence), and then we define the iterator below the collection definition:</p><div class='code' >template&nbsp;&lt;class&nbsp;T&gt;&nbsp;class&nbsp;col_iterator;&nbsp;//&nbsp;Declaration<br><br>//&nbsp;Collection&nbsp;class&nbsp;definition&nbsp;&nbsp;here&nbsp;...<br><br>template&nbsp;&lt;class&nbsp;T&gt;<br>class&nbsp;col_iterator&nbsp;//&nbsp;Definition<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Iterator&nbsp;Definition&nbsp;Goes&nbsp;Here<br>}<br></div><p>There a few things an iterator needs in order to be STL compatible. This also depends on the type of the iterator. The types of iterators are:</p><ul><li>Input Iterators</li><li>Output Iterators</li><li>Forward Iterator</li><li>Bidirectional Iterators</li><li>Random-Access Iterators</li></ul><p>Each of these have different requirements. For the sake of simplicity, we will be defining a <b>Forward Iterator</b> for our collection, which has less requirements. These are the requirements for <b>Forward Iterators</b>:</p><ol><li> <b>Iterator Characteristics</b> - Five member type definitions which describe the iterator type and datatypes that iterator is related to.</li><li> <b>Default Constructor</b> -  Ability to construct the iterator with no arguments</li><li> <b>Dereference Operator *</b> - to access the underlying data the iterator is "pointing" towards.</li><li> <b>Not-Equal Operator !=</b> - to know when iterators are not equal to one another</li><li> <b>Pre-Increment Operator ++</b> - to increment the iterator.</li><li> <b>Post-Increment Operator ++</b> - to create and return an incremented iterator.</li></ol><p>And that's it! If these elements are present in a class it is a valid iterator that can be used with STL algorithms. These members must be publically accessible.</p><p>Let's define our iterator in code:<div class='code' >#include&nbsp;&lt;iterator&gt;<br><br>template&nbsp;&lt;class&nbsp;T&gt;<br>class&nbsp;col_iterator<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;T*&nbsp;data;<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;iterator_category&nbsp;=&nbsp;std::forward_iterator_tag;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;value_type&nbsp;=&nbsp;T;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;difference_type&nbsp;=&nbsp;size_t;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;pointer&nbsp;=&nbsp;T*;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;reference&nbsp;=&nbsp;T&;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator(){}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator(pointer&nbsp;_data)&nbsp;:&nbsp;data(_data)&nbsp;{}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;pointer&nbsp;data()&nbsp;{&nbsp;return&nbsp;data;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;operator*()&nbsp;{&nbsp;return&nbsp;*data;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator!=(const&nbsp;col_iterator&&nbsp;other)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;!=&nbsp;other.data();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&&nbsp;operator++()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;+=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&nbsp;operator++(int)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_iterator&lt;T&gt;(data&nbsp;+&nbsp;1);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br></div><p>As you can see we have defined all the required elements of a <b>Forward Iterator</b>. One thing to note is the member <b>iterator_category</b>. It uses the <b>std::forward_iterator_tag</b> from the standard library marking this iterator as a <b>Forward Iterator</b>. These tags are available in <b>&lt;iterator&gt;</b>.</p><p>Now our class should easily work with STL algorithms such as the following:<div class='code' >Collection&lt;int,&nbsp;5&gt;&nbsp;test;<br>std::fill(test.begin(),&nbsp;test.end(),&nbsp;10);<br></div><p>To get more familiar with iterators:</p><ul><li>Add constant iterators to your collection ( define <b>cend()</b> and <b>cbegin()</b>).</li><li>Read up on the different iterator types and their specific requirements.</li><li>Implement different iterator types for your collection.</li><li>Try creating a collection with a different underlying type. For example using a linked-list instead of c-array. The increment and decrement methods will be much different.</li></ul><h2>Complete Code Example</h2><div class='code' >#include&nbsp;&lt;iterator&gt;<br>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;algorithm&gt;<br><br>template&nbsp;&lt;class&nbsp;T&gt;&nbsp;class&nbsp;col_iterator;<br><br>template&lt;class&nbsp;T,&nbsp;int&nbsp;N&gt;<br>class&nbsp;Collection<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;data[N]&nbsp;=&nbsp;{&nbsp;0&nbsp;};<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&nbsp;begin()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_iterator&lt;T&gt;(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&nbsp;end()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_iterator&lt;T&gt;(data&nbsp;+&nbsp;N);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>template&nbsp;&lt;class&nbsp;T&gt;<br>class&nbsp;col_iterator<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;T*&nbsp;data;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;iterator_category&nbsp;=&nbsp;std::forward_iterator_tag;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;value_type&nbsp;=&nbsp;T;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;difference_type&nbsp;=&nbsp;size_t;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;pointer&nbsp;=&nbsp;T*;<br>&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;reference&nbsp;=&nbsp;T&;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator(){}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator(pointer&nbsp;_data)&nbsp;:&nbsp;data(_data)&nbsp;{}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;operator*()&nbsp;{&nbsp;return&nbsp;*data;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator!=(const&nbsp;col_iterator&&nbsp;other)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;!=&nbsp;other.data;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&&nbsp;operator++()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;+=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;col_iterator&lt;T&gt;&nbsp;operator++(int)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;col_iterator&lt;T&gt;(data&nbsp;+&nbsp;1);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>int&nbsp;main(void)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Collection&lt;int,10&gt;&nbsp;test;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;std::fill(test.begin(),&nbsp;test.end(),&nbsp;2);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;std::transform(test.begin(),&nbsp;test.end(),&nbsp;test.begin(),&nbsp;[](int&nbsp;i)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i&nbsp;*&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for(auto&nbsp;t&nbsp;:&nbsp;test)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;t&nbsp;&lt;&lt;&nbsp;std::endl;<br>}&nbsp;&nbsp;&nbsp;<br></div></p></p></blank></content></item><item><title> Cookie-based Session Management</title><link> https://davidgorski.ca/posts/sessions/index.html</link><description> The Bare Necessities of Authentication and Recording User Status</description><content type='html' ><blank><p>Web frameworks had held my hand. Which for a beginner was great, but a lot of the fundamental aspects of back-end development had been abstracted from me, and I found annoying discrepancies between my knowledge and know-how. Sessions were one element I had neglected. I had taken them for granted; somehow magically some level of state is maintained between the server and the client.</p><p>It wasn't till I started writing my <a href='https://github.com/dgski/baseketbase-agg' >News Aggregator</a> Project in <a href='https://racket-lang.org' >Racket</a> that I realized I don't really know how sessions work. Racket's a great language, but it's not exactly popular and doesn't have any web frameworks. I needed to learn and write my own session manager. So I did.</p><p>How exactly does the server know whether a given client is logged in? Turns out it's mainly about <b>cookies</b>. Cookies are small collections of data that the server asks the client to store. They are transmitted in the HTTP request headers under the <b>Cookie</b> section, and held by the browser on the client's end. </p><p>For sessions, the server generates a session id, tells the client to remember it, the client does so and attaches that sid to following requests, so the server knows whether a request belongs to an authenticated session or not.</p><p>To better understand how this works; let's write a simple HTTP request handler. We will use the basic web server provided in python's <b>http.server</b> package. </p><p>We will start with three elements:</p><ul><li>address: this is the address and port at which the server will listen for connections</li><li>handler: this is a class which has the necessary methods to handle requests</li><li>server: we will initialize the built-in <b>HTTPServer</b> object with our address and handler.</li></ul><p>Finally, we will start our server using the <b>serve_forever()</b> method:</p><div class='code' >from&nbsp;http.server&nbsp;import&nbsp;*<br><br>#Setup<br>address&nbsp;=&nbsp;('',&nbsp;8000)<br>handler&nbsp;=&nbsp;BaseHTTPRequestHandler<br>server&nbsp;=&nbsp;HTTPServer(address,&nbsp;handler)<br><br>#Start<br>server.serve_forever()<br></div><p>We can send a request to our new server using a browser at <b>localhost:8000</b>. However, we should still the following error:</p><div class='code' >Error&nbsp;response<br><br>Error&nbsp;code:&nbsp;501<br><br>Message:&nbsp;Unsupported&nbsp;method&nbsp;('GET').<br><br>Error&nbsp;code&nbsp;explanation:&nbsp;HTTPStatus.NOT_IMPLEMENTED&nbsp;-<br>Server&nbsp;does&nbsp;not&nbsp;support&nbsp;this&nbsp;operation.<br></div><p>Looks like our handler can't handle simple <b>GET</b> requests... We need to do something about that. Define a new class at the top of the file. We still use <b>BaseHTTPRequestHandler</b> as the parent class, but add the <b>do_GET()</b> method:</p><div class='code' ><br>class&nbsp;SessionHandler(BaseHTTPRequestHandler):<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_GET(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;"Hello"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br><br></div><p>Remember to change the handler to our new class:</p><div class='code' >handler&nbsp;=&nbsp;SessionHandler<br></div><h2>Dispatching</h2><p>Now if you visit again with your browser, you should now see the raw text, "Hello" displayed. That's a good start, but we need our server to do different things based on different URL paths. Let's add a simple dispatcher and methods to handle the paths:</p><div class='code' >class&nbsp;SessionHandler(BaseHTTPRequestHandler):<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_GET(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/login":&nbsp;&nbsp;&nbsp;self.login,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/logout":&nbsp;&nbsp;self.logout,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.home<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;routes[self.path]()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;404<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;"Not&nbsp;Found"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_response(response)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.end_headers()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;home(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Welcome&nbsp;Home"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;login(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;todo:&nbsp;perform&nbsp;login<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;In"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;logout(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;todo:&nbsp;perform&nbsp;logout<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;Out"<br></div><p>Okay, things are taking shape. Let's run through what was added:</p><ul><li>The <b>routes</b> dictionary has paths as keys and page methods as values.</li><li>We use the <b>try,except</b> statement to try to access the methods using the path. If it works, we set <b>response</b> to 200 (success) and prepare our content. Otherwise, we set <b>response</b> to 404 (not found) and set content to <b>Not Found</b>.</li><li>The home, login and logout methods return a text string representing themselves.</li></ul><h2>Logging In</h2><p>Now let's implement our login process. After a user logs in, the time spent logged in is referred to as a <b>session</b>. For each login and consecutive logout, we will have a unique session id (sid). So obviously, our next immediate step is to generate a new <b>sid</b> when the user clicks on login. We will use a dictionary to store our sessions ids. Usually a database fulfills this role, but for our simple purposes, this should be enough. For incredibly basic security import the randint function:</p><div class='code' >from&nbsp;random&nbsp;import&nbsp;randint<br></div><p>Add the following method to generate the sid:</p><div class='code' >def&nbsp;generate_sid(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"".join(str(randint(1,9))&nbsp;for&nbsp;_&nbsp;in&nbsp;range(100))<br></div><p>Add a global dictionary to the top of the file:</p><div class='code' >sessions&nbsp;=&nbsp;{}<br></div><p>Make the following changes to the <b>login</b> method:<div class='code' >def&nbsp;login(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Password&nbsp;normally&nbsp;be&nbsp;checked&nbsp;here<br>&nbsp;&nbsp;&nbsp;&nbsp;sid&nbsp;=&nbsp;self.generate_sid()<br>&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid={}".format(sid)<br>&nbsp;&nbsp;&nbsp;&nbsp;sessions[sid]&nbsp;=&nbsp;{"username",&nbsp;"useragent","ip&nbsp;address","expiry"}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;In"<br></div><p>Add the following <b>send_header</b> function calls to bottom of the <b>do_GET</b> method:<div class='code' >def&nbsp;do_GET(self):&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;#...<br>&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;None&nbsp;#&nbsp;Addition<br>&nbsp;&nbsp;&nbsp;&nbsp;self.send_response(response)<br>&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.cookie:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Set-Cookie',&nbsp;self.cookie)&nbsp;#&nbsp;Addition<br>&nbsp;&nbsp;&nbsp;&nbsp;self.end_headers()<br>&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br>&nbsp;&nbsp;&nbsp;&nbsp;return<br></div><p>What is happening should be clear: <b>login()</b> is setting the <b>self.cookie</b> member variable to a random string of numbers, and <b>self.send_header('Set-Cookie', self.cookie)</b> is sending it off as a cookie value. Now if you visit <b>/login</b> in your browser, and open up the web inspector, you should see <b>sid</b> as a cookie, with the value as whatever you generated. This cookie is held by the browser, and will be forwarded to our server with every request. It provides 'context' between requests.</p><p>Also, notice that <b>login()</b> adds the sid to the dictionary as a key with a dummy dictionary <b>{"username", "useragent","ip address","expiry"}</b> as a value. This is where a complete session manager would store those pieces of information about the user, to later verify the session. Add this on your own.</p><h2>Validating users</h2><p>Now we need to perform the most fundamental aspect of session management: validating a session. Let's say there is some content that only registered, logged in users can see. We don't want our user to have to provide their password with each page request; That would be incredibly cumbersome. We need to check if a request contains a session and display the right thing. We need to extract a header's sid to get that information. Add the following method to our <b>SessionHandler</b> class:</p><div class='code' >def&nbsp;parse_cookies(self,&nbsp;cookie_list):<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dict(((c.split("="))&nbsp;for&nbsp;c&nbsp;in&nbsp;cookie_list.split(";")))&nbsp;if&nbsp;cookie_list&nbsp;else&nbsp;{}<br></div><p>This will nicely extract the cookies string from the request and put it into a dictionary for our convenience. Also alter our <b>do_GET</b> <b>try</b> block so it looks like this:</p><div class='code' >try:<br>&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;cookies&nbsp;=&nbsp;self.parse_cookies(self.headers["Cookie"])<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;"sid"&nbsp;in&nbsp;cookies:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;cookies["sid"]&nbsp;if&nbsp;(cookies["sid"]&nbsp;in&nbsp;sessions)&nbsp;else&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;routes[self.path]()<br></div><p>Our home page should display whether a user is currently logged in:<div class='code' >def&nbsp;home(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Welcome&nbsp;User!"&nbsp;if&nbsp;self.user&nbsp;else&nbsp;"Welcome&nbsp;Stranger!"<br></div><p>What is happening here? Take a closer look at the try block. There are a few interesting things happening within:</p><ul><li>As before, we are setting the response to code 200, which for a HTTP request, it means that the page was found</li><li>Secondly, we are parsing the <b>Cookie</b> section of the header. Our <b>parse_cookies</b> method splits the Cookie string by ";" to seperate the individual cookies, then it puts the cookie ids and their values into a dictionary. If there are no cookies, it responds with an empty dictionary</li><li>Next, our try block checks if "sid" is in the <b>cookies</b> dictionary. If it isn't, it sets <b>self.user</b> to false. Otherwise, it then checks whether the sid value stored in the <b>sessions</b> global.</li><li>From then on, it's business as usual.</li></ul><p>We have altered a fundamental behaviour of our micro-program: when we visit the homepage without a generated sid cookie being broadcast by the browser we will see:<div class='code' >"Welcome&nbsp;Stranger!"<br></div><p>Clearly, unless the sid is stored in the <b>sessions</b> dictionary, the application instance does not recognize the web user. But if the user logs in using the rudimentary <b>/login</b> page, it will display:<div class='code' >"Welcome&nbsp;User!"<br></div><p>Try logging in, and then restarting our server. If you return to the home page, it won't recognize you, even if the browser holds and sends a <b>sid</b> cookie. Because the dictionary dies with the process, our server completely forgets about the session. If you visit the <b>login</b> page again, a new <b>sid</b> is generated, and we get <b>"Welcome User!"</b>.</p><p>To Recap: the login process generates a new sid, saves the users information(user agent, ip address, etc), and sends back a header asking for the user's browser to remember the new sid. Of course to be useful in most cases,  you would have to validate a login password before generating the sid and continuing, but the fundamental aspects of session management are already present.</p><h2>Logging Out</h2><p>What if the user wants to end their session? Well, we should probably give them a log out page as well. Let's add something to our currently useless logout page:<div class='code' >&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;logout(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;self.user:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Can't&nbsp;Log&nbsp;Out:&nbsp;No&nbsp;User&nbsp;Logged&nbsp;In"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid="<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;del&nbsp;sessions[self.user]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;Out"<br></div><p>This method will check if a valid user is logged in, set the cookie to empty and delete the session id from the <b>sessions</b> dictionary, before returning the <b>"Logged Out"</b> text.</p><p>Check out what happens now: restart our your server application, open it and validate the following happens in order:</p><ol><li> On First Visit of the home page <b>"/"</b> it should display: "Welcome Stranger!".</li><li> If you now visit <b>"/login"</b>, it should display "Logged In", check your cookies for the "/" domain, you should see an <b>sid</b> cookie with the newly generated session.</li><li> Now if you visit the home page, your should see: "Welcome User!". Congratulations, your session has been validated!</li><li> Next test if the <b>"/logout"</b> page works. Visit it, it should say "Logged Out". Make sure it worked by once again checking your cookies in your browser. The <b>sid</b> cookie should be empty.</li><li> If you visit the home page again, it should display: "Welcome Stranger!". You have successfully logged out.</li></ol><p>The complete code should now look like:<div class='code' >from&nbsp;http.server&nbsp;import&nbsp;*<br>from&nbsp;random&nbsp;import&nbsp;randint<br><br>sessions&nbsp;=&nbsp;{}<br><br>class&nbsp;SessionHandler(BaseHTTPRequestHandler):<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_GET(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/login":&nbsp;self.login,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/logout":&nbsp;self.logout,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/":&nbsp;self.home<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;None<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cookies&nbsp;=&nbsp;self.parse_cookies(self.headers["Cookie"])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;"sid"&nbsp;in&nbsp;cookies:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;cookies["sid"]&nbsp;if&nbsp;(cookies["sid"]&nbsp;in&nbsp;sessions)&nbsp;else&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;routes[self.path]()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;404<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;"Not&nbsp;Found"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_response(response)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.cookie:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Set-Cookie',&nbsp;self.cookie)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.end_headers()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;home(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Welcome&nbsp;User!"&nbsp;if&nbsp;self.user&nbsp;else&nbsp;"Welcome&nbsp;Stranger!"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;login(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Password&nbsp;would&nbsp;normally&nbsp;be&nbsp;checked&nbsp;here<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sid&nbsp;=&nbsp;self.generate_sid()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid={}".format(sid)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sessions[sid]&nbsp;=&nbsp;{"username",&nbsp;"useragent","ip&nbsp;address","expiry"}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;In"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;logout(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;self.user:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Can't&nbsp;Log&nbsp;Out:&nbsp;No&nbsp;User&nbsp;Logged&nbsp;In"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid="<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;del&nbsp;sessions[self.user]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;Out"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;generate_sid(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"".join(str(randint(1,9))&nbsp;for&nbsp;_&nbsp;in&nbsp;range(100))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;parse_cookies(self,&nbsp;cookie_list):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dict(((c.split("="))&nbsp;for&nbsp;c&nbsp;in&nbsp;cookie_list.split(";")))&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cookie_list&nbsp;else&nbsp;{}<br><br>address&nbsp;=&nbsp;('',&nbsp;8000)<br>handler&nbsp;=&nbsp;SessionHandler<br>server&nbsp;=&nbsp;HTTPServer(address,&nbsp;handler)<br><br>server.serve_forever()<br></div><p>Please read more about cookies, their expiration setting, and elements of session security before deploying anything like this. There are many more standard practices to consider; including encrypting the session id. Stay Safe!</p></p></p></p></p></p></p></p></blank></content></item><item><title> Collector Functions in Scheme</title><link> https://davidgorski.ca/posts/collectors-in-scheme/index.html</link><description> Building and Passing Lambda Sandwiches</description><content type='html' ><blank><p>The Collector paradigm is a functional way of assembling and processing collections of data. As a design pattern it also offers a few benefits, and at the very least provides a unique academic exercise.</p><p>I've recently been working through the classic book; <a href='https://www.goodreads.com/book/show/548914.The_Little_Schemer' >The Little Schemer</a>, which is a cute and concise introduction to Scheme. The Chapter covering this topic delivered the first real friction, so I took some time to chew through it, understand it, and expand its explanation.</p><p>Let's start by defining a function which takes a list of numbers, and uses the collector paradigm to sort the numbers into two categories, Odd and Even:</p><div class='code' >(define&nbsp;sep-odds<br>&nbsp;&nbsp;(lambda&nbsp;(lat&nbsp;col)<br>&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;lat)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col&nbsp;'()&nbsp;'()))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;(modulo&nbsp;(car&nbsp;lat)&nbsp;2)&nbsp;0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sep-odds&nbsp;(cdr&nbsp;lat)&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col&nbsp;odds&nbsp;(cons&nbsp;(car&nbsp;lat)&nbsp;evens)))))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sep-odds&nbsp;(cdr&nbsp;lat)&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col&nbsp;(cons&nbsp;(car&nbsp;lat)&nbsp;odds)&nbsp;evens)))))))<br></div><p>This function will consume two arguments: a list of numbers (lat) and a collector function (col). Its body consist's of one <b>cond</b> statement with 3 branches:</p><table><tr><th>Branch                       </th><th> Description</th></tr><tr><td>(null? lat)                  </td><td> Checks if <b>lat</b> is empty</td></tr><tr><td>(= (modulo (car lat) 2) 0)   </td><td> Checks if the first entry in the list is even</td></tr><tr><td>else                         </td><td> Concludes first list entry must be odd</td></tr></table><p>Take a note as to how <b>sep-odds</b> recurs: It does not build a list in the simple way of functionally building up a collection. Instead, if <b>sep-odds</b> is to recur it builds a lambda function which will perform a particular task (in this case using <b>cons</b> to prepend the number to one of the lists) and then passes this lambda function to the next call of <b>sep-odds</b> as the <b>col</b> argument.</p><p>Wrapping a task in a lambda is a neat trick: It delays execution of the wrapped code until the lambda is called.</p><p>Another neat trick is that <b>sep-odds</b> stuffs the previous collector function (bound to <b>col</b> as a function parameter) into the new lambda's body. I like to visualize this as a sandwich, with previous collectors being stuffed inside new ones. Finally, when one of these lambdas is called, it does its work, and then calls the collector function embedded inside it.</p><p>For our <b>sep-odds</b> function, you may notice that we need to provide an initial collector. Let's get to it.</p><p><b>First Time with Scheme?</b> <i>Please Note: (car x) returns the first element of the list x, and (cdr x) returns list x excluding the first element.</i></p><p>We will define <b>list</b> as our 0th collector. This will be the very centre of the lambda function sandwich:</p><div class='code' >(define&nbsp;col-0&nbsp;list)<br></div><p>Now let's step through what happens when we perform the following function call:</p><div class='code' >(sep-odds&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;col-0)&nbsp;;&nbsp;return&nbsp;value&nbsp;-&gt;&nbsp;((1&nbsp;3)&nbsp;(2&nbsp;4))<br></div><p><b>(car lat)</b> for the first call of sep-odds is <b>1</b>, therefore the third condition (<b>else</b>) is matched. This will generate a new lambda with <b>col-0</b> as <b>col</b> and <b>1 (car lat)</b> inside it. For clarity, we will label this newly generated lambda function as <b>col-1</b>:</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;1&nbsp;to&nbsp;the&nbsp;odds&nbsp;list<br>(define&nbsp;col-1<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-0&nbsp;(cons&nbsp;1&nbsp;odds)&nbsp;evens)))<br></div><p>This conditional branch will then call sep-odds again, with the rest of the list <b>(cdr lat)</b> and the newly-generated <b>col-1</b> as arguments:</p><div class='code' >(sep-odds&nbsp;'(2&nbsp;3&nbsp;4)&nbsp;col-1)<br></div><p>After this second function call the second conditional branch <b>(= (modulo (car lat) 2) 0)</b> is triggered as 2 is an even number. Same story again: a new lambda is built, but this time <b>col-1</b> is bound to <b>col</b>:</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;2&nbsp;to&nbsp;the&nbsp;evens&nbsp;list<br>(define&nbsp;col-2<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-1&nbsp;odds&nbsp;(cons&nbsp;2&nbsp;evens))))<br></div><p>Now <b>col-2</b> and the remainder of the list will serve as the arguments for the <b>sep-odds</b> recursive call:</p><div class='code' >(sep-odds&nbsp;'(3&nbsp;4)&nbsp;col-2)<br></div><p>We repeat, again with an odd number (<b>3</b>):</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;3&nbsp;to&nbsp;the&nbsp;odds&nbsp;list<br>(define&nbsp;col-3<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-2&nbsp;(cons&nbsp;3&nbsp;odds)&nbsp;evens)))<br></div><p>and our next call:</p><div class='code' >(sep-odds&nbsp;'(4)&nbsp;col-3)<br></div><p>Again, with an even number (<b>4</b>):</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;4&nbsp;to&nbsp;the&nbsp;evens&nbsp;list<br>(define&nbsp;col-4<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-3&nbsp;odds&nbsp;(cons&nbsp;4&nbsp;evens))))<br></div><p>Finally, since the input list is empty, the <b>null?</b> conditional is triggered with this final call:</p><div class='code' >(sep-odds&nbsp;'()&nbsp;col-4)<br></div><p>That <b>null?</b> conditional applies the <b>col</b> function. In this case it is our latest, <b>col-4</b>:</p><div class='code' >;&nbsp;excerpt:<br>((null?&nbsp;lat)&nbsp;(col-4&nbsp;'()&nbsp;'()))<br></div><p>At this moment our sandwich is at its juiciest. Each layer takes an input from the previous one, as the layers are stripped away. We will begin with the outside 'bun' of the sandwich and go inwards. Each collector function calls the collector embedded within it:</p><div class='code' >(define&nbsp;col-4<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-3&nbsp;odds&nbsp;(cons&nbsp;4&nbsp;evens))))<br>;&nbsp;&nbsp;&nbsp;|____|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;col-3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-2&nbsp;(cons&nbsp;3&nbsp;odds)&nbsp;evens)))<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|____|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;col-2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-1&nbsp;odds&nbsp;(cons&nbsp;2&nbsp;evens))))<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|____|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;col-1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-0&nbsp;(cons&nbsp;1&nbsp;odds)&nbsp;evens)))<br><br></div><p>We are lucky we used labels, In reality the lambda generated looks like this:</p><div class='code' >(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-0&nbsp;(cons&nbsp;1&nbsp;odds)&nbsp;evens))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;odds&nbsp;(cons&nbsp;2&nbsp;evens)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;3&nbsp;odds)&nbsp;evens))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;odds&nbsp;(cons&nbsp;4&nbsp;evens)))<br></div><p>And this is how the function calls look with the computed values of the arguments:</p><div class='code' >1.&nbsp;(col-4&nbsp;'()&nbsp;'())<br>2.&nbsp;(col-3&nbsp;'()&nbsp;'(4))<br>3.&nbsp;(col-2&nbsp;'(3)&nbsp;'(4))<br>4.&nbsp;(col-1&nbsp;'(3)&nbsp;'(2&nbsp;4))<br>5.&nbsp;(col-0&nbsp;'(1&nbsp;3)&nbsp;'(2&nbsp;4))<br>6.&nbsp;(list&nbsp;'(1&nbsp;3)&nbsp;'(2&nbsp;4))<br>7.&nbsp;((1&nbsp;3)&nbsp;(2&nbsp;4))<br></div><p>All of these expressions have the same value.</p><p>So now the big question: Why? Why complicate things like this? Why not just use multiple lists as arguments to gather the data we want?</p><p>Well, Collector functions offer two advantages: Delayed Execution, and Continuations.</p><p>To address the first point, in this example, each generated lambda is doing something relatively inexpensive: using <b>cons</b> to prepend a number to a list. But what if it was performing some sort of expensive operation? For example: performing operations on a matrix with massive proportions, or rendering graphics. Perhaps there is hypothetical example where we do not want to do anything computationally expensive until the data input has been completely verified, from start to finish? In that case a collector paradigm would work well. Building the collector works sort of as a type of manifest or queue, of operations to be performed.</p><p>Secondly, if you have a function which represents a series of steps, and each step has their own state, you can travel back to these states. In effect, you save a snapshot of that point in time. And in Scheme, since you can pass function along; you can pass these snapshots around. This gives you flexibility to return back to times where data was valid or matched some sort of pattern. One thing that comes to mind is traversing a Tree data structure and if you are exploring the children of a branch, you can pass forward a collector that represents that root, until you reach something you need and feed that data into the collector.</p></blank></content></item></channel></rss>