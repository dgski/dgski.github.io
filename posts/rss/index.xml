<?xml version='1.0' encoding='UTF-8' ?><rss version='2.0' ><channel><title> David Gorski</title><item><title> Five Web Project Lessons</title><link> https://davidgorski.ca/posts/lessons-developing-web-project/index.html</link><description> What I Learned Developing and Deploying My First Complete Web Application</description><content type='html' ><blank><p><i>This article is based off a short talk I gave at <a href='https://www.meetup.com/DevHouse-Waterloo/' >DevHouse Waterloo</a></i>.</p><p>Last month, I finally launched my collaborative map-based urban planning web application: <a href='https://plantogether.city' >Plan Together</a>. It was a lot of work, but I must say I am proud of the result; it is my most feature-complete project to date. It's quite an experience having to do 100% of the work for product development, system architecture design, programming, and user interface/experience design. It definitely increases one's respect for the work of their co-workers in different departments. I highly recommend it.</p><p>Here are some lessons I learned along the way from a software developer's point of view:</p><h1>1. Consider HTTP request Overhead</h1><p>As a C++ Back-End Web Service Developer I work mainly with a in-house binary transmission protocol which composes and parses the bare minimum of bytes per message. Sending data which is not directly relevant is considered an affront. During the initial design and prototype phase, my driving philosophy was to send many small requests, retrieving only what was immediately necessary. However, during trials, I had to confront the fact that each individual HTTP request is padded with a rather large amount of overhead due to Headers. I was forced to reduce the number of requests and increase their size, which is the logical approach from a web developer's point of view. Lesson learned.</p><h1>2. Remember Database Access Overhead</h1><p>Theoretically, this is an obvious one. But nothing hits you as hard as actually having to design data shape and retrieval processes yourself. Just as with HTTP requests, my initial approach had numerous small SELECTs, in an effort preventing retrieval of data that might not be needed. Originally, one SELECT would retrieve a collection of ids (defining relevant records), and other SELECTs would retrieve other data columns as needed. I was being too clever. Maybe my approach would work if database access was free, but that is far from the case. It became very clear; it is better to perform wider queries, selecting more information than needed. Go in, grab a chunk of mostly relevant data, and exit. Finally, cache it. Disturbing the database should be your last resort.</p><h1>3. Good deployment pipelines are hard to implement (But Worth It)</h1><p>As a developer at a large company, automated build setup, production deployment and configuration are parts of the software world that I don't need to touch. I just focus on my teams specific modules, write code that fulfills requirements, and follow existing guidelines. After code is reviewed and tested, it is out of my hands. I do not directly take the code and make it do live work for users. Since I was the only person working on <a href='https://plantogether.city' >Plan Together</a>, I obviously had to do it myself. Sometimes, configuration is pure hell. Figuring out the details of how GitHub Actions are triggered, which cloud platforms are best for your Front-End and Back-End, and how to best deploy your application takes a while and feels very unproductive. It was hard to let go of the mindset that if I was not working on the code or the concept, I was wasting time. Now, I am happy I spent that time. I can easily deploy changes just by merging feature-branches into the production branch and all deployment is automatic.</p><h1>4. Most External APIs are easy to integrate</h1><p>We are really living in a Golden Age of integration. Adding external features to your product is easier than ever. Finally writing something myself proved this directly. The <a href='https://plantogether.city' >Plan Together</a> application automatically posts certain Map Items to twitter, mentioning relevant accounts: <a href='https://twitter.com/cityofcalgary/status/1228341986924679168' >City Of Calgary Tweet Example</a>. I was surprised how easy this was to implement. I applied for a Twitter Developer Account, integrated the relevant library into the code-base and was easily able to start tweeting map images.</p><h1>5. Ruthlessly Prioritize Features and Focus on Releasing Anything</h1><p>It becomes very easy to delay a release. Feature and scope creep are real. And especially since you are the only person working on this project, your ego becomes tied up in it. You want it to be good enough, you start daydreaming of a big launch. So you keep adding more and more to the product. I caught myself doing this more than once during development. Now, after the initial release, I realized how important it is to get something out there into the real world. Not only do you get real feedback, but your self-pressure is taken off your shoulders. I have actually been able to accelerate development since release and added a handful new features: <a href='https://blog.plantogether.city/post/version-2-features/' >9 New Features in Plan Together 2.0</a></p><p>Thanks for reading my article! Feel free to checkout <a href='https://plantogether.city' >Plan Together</a>, or email me with comments/questions at <a href='mailto:dg@davidgorski.ca' >dg@davidgorski.ca</a>.</p></blank></content></item><item><title> Back-End Development Basics</title><link> https://davidgorski.ca/posts/backend-dev/index.html</link><description> Simple Questions and Considerations for Server Software</description><content type='html' ><blank><h2>Know your Data</h2><p>It is most important for a back-end developer to understand the characteristics of the Data their software will interact with. This includes both data inflows and data outflows. Questions such as the following need to be asked:</p><ul><li>How much data is incoming?</li><li>What is the shape/type of the data?</li><li>How should this data be processed?</li><li>Where is this data needed or useful?</li><li>What is the corresponding response to this type of data?</li><li>How soon is a response needed?</li></ul><p>After careful deliberation and analysis, implementation details will naturally emerge regarding load balancing, API design, data structures, micro-service division of labor, parallelization of processing, replication, stream-publishing, table design, caching, relational vs key-value etc. </p><p>The data is the canonical source for developing robust back-end endpoints and services. This is relevant from the high-level architectural decisions all the way to direct coding.</p><p>For example, a service which handles low data volume, with simply query parameters, with low amounts of processing (CRUD), with no real-time requirements in response time, can and should be incredibly simple. There is no reason to over-complicate things. A basic load-balancer paired with a simple web-app and simple db is good enough (with regular backups of course).</p><p>Conversely, a service which handles billions of requests a day, with high levels of processing, and many orthogonal services waiting for the data will need specialized streams/queues, parallel processing, advanced backup systems, specialized data structures with aggressive caching.</p><h2>Architecture</h2><h3>System scaling</h3><p>For high-performance, high-throughput systems, it is important to get the basics right. Paying attention to the data you are dealing with, and analyzing the space and time complexities of your algorithms is crucial.</p><ul><li>Use appropriate algorithms and data structures</li><li>Lift load on resources as soon as possible. (Early returns, forwarding requests to relevant module, etc)</li><li>Check for and handle errors as early as possible. Prevent propagation of errors.</li><li>Find a good point of modularity (monolith vs microservices)</li><li>As simple as possible data distribution and replication pipeline.</li><li>Determine level of Data normalization (optimize for speed vs optimize for reduction of redundancy)</li></ul><h3>Maintainability</h3><p>For large systems, it is important to build services for maintainability. This includes using:</p><ul><li>Clean, clear code</li><li>Simple abstractions</li><li>Microservices for separation of concern</li><li>Well-defined, versioned APIS, as well as organization process for creating new endpoints</li><li>Re-use what you can</li><li>Cherry-pick suitable design patterns (SOLID, functional, etc...), do not force</li></ul></blank></content></item><item><title> The Fixed-Point Combinator Function</title><link> https://davidgorski.ca/posts/combinator/index.html</link><description> Implementing Functional Recursion as a Non-Primitive Feature</description><content type='html' ><blank><p>The goal of this article is to explain the purpose and functionality of <b>fixed-point combinator functions</b>. I had a hard time following along with other articles on this topic so I wrote this as a learning exercise. We'll be using the <b>Scheme</b> language.</p><p>So what is a <b>fixed-point combinator</b>? It is a function which given a function as an argument, returns a fixed point of that function. Let's demonstrate why this could be useful.</p><p>First, let start by defining a factorial function recursively:</p><div class='code' >(define&#160;fact&#160;<br></br>&#160;&#160;(lambda&#160;(n)<br></br>&#160;&#160;&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(fact&#160;(-&#160;n&#160;1))))))<br></br></div><p>Theoretically, if our language suddenly loses recursion as a feature we run into a big problem; we can't refer to a function that is not bound! There is no 'self' keyword inside a anonymous function (which would let us reference the function from within) and therefore the function will no longer be valid:</p><div class='code' >(lambda&#160;(n)<br></br>&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(???&#160;(-&#160;n&#160;1)))))<br></br></div><p>To clarify, the function is actually valid, but only for an input of <b>0</b>:</p><div class='code' >;&#160;0&#160;-&gt;&#160;1<br></br><br></br>((lambda&#160;(n)<br></br>&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(???&#160;(-&#160;n&#160;1)))))&#160;0)<br></br></div><p>But if we try with any other value, it will fail:</p><div class='code' >;&#160;1&#160;-&gt;&#160;error:&#160;unbound&#160;symbol&#160;(???)<br></br><br></br>((lambda&#160;(n)<br></br>&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(???&#160;(-&#160;n&#160;1)))))&#160;1)<br></br></div><p>An input of <b>1</b> does not fulfill the first condition <b>(zero?)</b>, so it attempts to call <b>???</b> with <b>(- n 1)</b> as it's argument. <b>???</b> is a symbol not bound to anything so an error is raised. However, we do know that for the current call the expression <b>(- n 1)</b> is equal to <b>0</b>, since <b>n</b> is bound to <b>1</b>. We know this function works for zero, so we know we can simply substitute it in for <b>???</b>. Now we have a function that works for two inputs: 0 and 1:</p><div class='code' >((lambda&#160;(n)<br></br>&#160;&#160;(if&#160;(zero?&#160;n)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;1<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(*&#160;n&#160;((lambda&#160;(n)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(???&#160;(-&#160;n&#160;1)))))&#160;(-&#160;n&#160;1)))))&#160;1)<br></br></div><p>Using the former logic we can continue this process, replacing <b>???</b> with our 'factorial' lambda; creating a function that can work with another successive input. This could get tedious, so let's write a function that does that for us.</p><div class='code' >(define&#160;fact-gen<br></br>&#160;&#160;(lambda&#160;(f)<br></br>&#160;&#160;&#160;&#160;(lambda&#160;(n)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(f&#160;(-&#160;n&#160;1)))))))<br></br></div><p>By itself, the return value is our <b>fact0</b> function, which we used unbound earlier, Since an input of 0 doesnt call the <b>f</b> function, we can pass anything we'd like.</p><div class='code' >(define&#160;fact0&#160;(fact-gen&#160;'trash))<br></br>&#160;-&gt;&#160;(lambda&#160;(next)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(n)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;('trash&#160;(-&#160;n&#160;1))))))<br></br><br></br>(fact0&#160;0)&#160;-&gt;&#160;1<br></br></div><p>However, due to the conditional statement, if input is greater than <b>0</b>, the argument will be called, and that's simply impossible as it is currently is just  a <b>'trash</b> symbol.</p><div class='code' >(fact0&#160;1)&#160;-&gt;&#160;ERROR<br></br></div><p>We need to supply a function that will give us the factorial of <b>(- 1 1)</b>. Wait a second... That expression equals <b>0</b>... We already have a function that gives us the factorial of <b>0</b>... Let's run <b>fact-gen</b> and pass it <b>fact0</b>.</p><div class='code' >(define&#160;fact&lt;=1&#160;(fact-gen&#160;fact0))<br></br></div><p>Using this newly generated function, we can find the factorial of any number equal or less than one. Can we continue? In fact, yes!</p><div class='code' >(define&#160;fact&lt;=2&#160;(fact-gen&#160;fact&lt;=1))<br></br></div><p>Now the next step is clear. We need to supply the consecutive factorial function to the previous factorial function n + 1 times (starting at 0). How can we continually feed the <b>fact-gen</b> function these next factorial functions? Turns out that a combinator function can do that for us:</p><div class='code' >(define&#160;combinator<br></br>&#160;&#160;(lambda&#160;(func)<br></br><br></br>&#160;&#160;&#160;&#160;(define&#160;make-step<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(next-step)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(arg)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((func&#160;(next-step&#160;next-step))&#160;arg))))<br></br><br></br>&#160;&#160;&#160;&#160;(lambda&#160;(arg)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;((func&#160;(make-step&#160;make-step))&#160;arg))))<br></br></div><p>Notice that the returned lambda at the end of <b>combinator</b> function and the returned lambda for the locally scoped function <b>make-step</b>, are exactly the same. This is crucial. That means that when the generated factorial function needs the next factorial function, it simply inserts itself again. Let's walk through this. Running <b>(combinator fact-gen)</b> will return:</p><div class='code' >;&#160;figure-1<br></br>(lambda&#160;(arg)<br></br>&#160;&#160;((fact-gen&#160;(make-step&#160;make-step))&#160;arg))<br></br></div><p>When this function is called with any argument it will first resolve the expression <b>(make-step make-step)</b>. This function call will return the following:</p><div class='code' >;&#160;figure-2<br></br>(lambda&#160;(arg)<br></br>&#160;&#160;((fact-gen&#160;(make-step&#160;make-step))&#160;arg))<br></br></div><p>Does this look familiar? Its the same as before! This is the fixed point. As seen in <b>figure-1</b>, this lambda (figure-2) will serve as the argument for the <b>(fact-gen figure-2)</b> function call, which returns:</p><div class='code' >;&#160;figure-3<br></br>(lambda&#160;(n)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(figure-2&#160;(-&#160;n&#160;1)))))<br></br></div><p>Let's call it with the argument of number '1': <b>(figure-3 1)</b>. Since 1 is not <b>zero?</b> the control flow will evaluate the next expression: <b>(* 1 (figure-2 (- 1 1)))</b>. Which includes the function call <b>(figure-2 (- 1 1))</b>. This will return the following:</p><div class='code' >((fact-gen&#160;(make-step&#160;make-step))&#160;arg)<br></br></div><p><b>(make-step make-step)</b> will again return:</p><div class='code' >;&#160;figure-4<br></br>(lambda&#160;(arg)<br></br>&#160;&#160;((fact-gen&#160;(make-step&#160;make-step))&#160;arg))<br></br></div><p>and the whole <b>figure-2</b> call will evaluate to:</p><div class='code' >;&#160;figure-5<br></br>(lambda&#160;(n)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(if&#160;(zero?&#160;n)&#160;1&#160;(*&#160;n&#160;(figure-4&#160;(-&#160;n&#160;1)))))<br></br></div><p>Just to clarify, we are currently evaluating <b>(* 1 (figure-2 (- 1 1)))</b>. <b>n</b> is bound to <b>0</b> in <b>figure-5</b>, so the <b>if</b> expression returns 1. Therefore everything resolves to:</p><div class='code' >(*&#160;1&#160;1)&#160;-&gt;&#160;1<br></br></div><p>And that's pretty much it. We can simplify the whole thing by eliminating our locale definition of <b>make-step</b> and replacing our readable variables with single letters:</p><div class='code' >(define&#160;Z<br></br>&#160;&#160;(lambda&#160;(f)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(a)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((f&#160;((lambda&#160;(y)&#160;(lambda&#160;(a)&#160;((f&#160;(y&#160;y))&#160;a)))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(y)&#160;(lambda&#160;(a)&#160;((f&#160;(y&#160;y))&#160;a)))))&#160;a))))<br></br></div></blank></content></item><item><title> Custom STL Compatible Iterators</title><link> https://davidgorski.ca/posts/stl-iterators/index.html</link><description> A Practical Start to Writing Simple Iteration Classes in C++</description><content type='html' ><blank><h2>What is an Iterator?</h2><p>The <b>Iterator</b> is the abstraction at the heart of all Collection-related functionality within the C++ Standard Library. Most algorithms are defined in terms of iterators. What is an iterator exactly?</p><p>Fundamentally, an Iterator represents a point of iteration. A point of iteration describes:</p><ul><li>How to retrieve the value at the point</li><li>How the point of iteration can be incremented/decremented</li><li>How to compare it with other points of iteration</li></ul><p>For example: Conceptually, if you are 'iterating' over a <b>book's pages</b>, the point of iteration could describe the following rules:</p><ul><li>The value at the point of iteration can be retrieved by reading the current page.</li><li>The point of iteration can be incremented by turning the page forward.</li><li>You can compare the point of iteration with other points of iteration by looking at the page number.</li></ul><p><i>Take note how this book example does not describe how to 'decrement' the iteration. Philosophically speaking, using this description; you could only ever turn the pages forward, never back.</i></p><p>In C++, iterators are defined as objects with methods describing their rules.</p><h2>Creating a Custom Collection</h2><p>First, we are going to create a custom collection type compatible with <b>STL algorithm constructs</b> and <b>ranged for-loops</b>. At that level of abstraction all we need to provide is <b>begin()</b> and <b>end()</b> methods, and then we will be able to write code like this:</p><div class='code' >Collection&#160;col;<br></br><br></br>for(auto&&#160;c&#160;:&#160;col)<br></br>&#160;&#160;&#160;&#160;cout&#160;&lt;&lt;&#160;c&#160;&lt;&lt;&#160;endl;<br></br><br></br>std::transform(begin(col),&#160;end(col),&#160;begin(col),&#160;[](auto&&#160;i)<br></br>{<br></br>&#160;&#160;&#160;&#160;return&#160;i&#160;*&#160;i;<br></br>});<br></br></div><p>Our collection will be a simple wrapper class around a c-array. This is what <b>std::array</b> provides in the Standard Library. In reality, you will only write custom collections and iterators if you need very particular data structures satisfying very specific requirements. Here is our collection definition:</p><div class='code' >template&lt;class&#160;T,&#160;int&#160;N&gt;<br></br>class&#160;Collection<br></br>{<br></br>&#160;&#160;&#160;&#160;T&#160;data[N]&#160;=&#160;{&#160;0&#160;};<br></br>public:<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&#160;begin()<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;col_iterator&lt;T&gt;(data);<br></br>&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&#160;end()<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;col_iterator&lt;T&gt;(data&#160;+&#160;N);<br></br>&#160;&#160;&#160;&#160;}<br></br>};<br></br></div><p>We take type and size as template arguments, create an array of that type and size. We also define methods which return the iterators to the beginning and end of the collection, passing the pointers to the first element (data) and just past the last element (data + N) as arguments.</p><h2>The Iterator Itself</h2><p>Now that we have created a collection-type, we need to define the iterator for use with the <b>begin()</b> and <b>end()</b> methods. First, we declare our iterator class ahead of our collection class declaration (The class needs to be aware of the iterator's existence), and then we define the iterator below the collection definition:</p><div class='code' >template&#160;&lt;class&#160;T&gt;&#160;class&#160;col_iterator;&#160;//&#160;Declaration<br></br><br></br>//&#160;Collection&#160;class&#160;definition&#160;&#160;here&#160;...<br></br><br></br>template&#160;&lt;class&#160;T&gt;<br></br>class&#160;col_iterator&#160;//&#160;Definition<br></br>{<br></br>&#160;&#160;&#160;&#160;//&#160;Iterator&#160;Definition&#160;Goes&#160;Here<br></br>}<br></br></div><p>There a few things an iterator needs in order to be STL compatible. This also depends on the type of the iterator. The types of iterators are:</p><ul><li>Input Iterators</li><li>Output Iterators</li><li>Forward Iterator</li><li>Bidirectional Iterators</li><li>Random-Access Iterators</li></ul><p>Each of these have different requirements. For the sake of simplicity, we will be defining a <b>Forward Iterator</b> for our collection, which has less requirements. These are the requirements for <b>Forward Iterators</b>:</p><ol><li> <b>Iterator Characteristics</b> - Five member type definitions which describe the iterator type and datatypes that iterator is related to.</li><li> <b>Default Constructor</b> -  Ability to construct the iterator with no arguments</li><li> <b>Dereference Operator *</b> - to access the underlying data the iterator is "pointing" towards.</li><li> <b>Not-Equal Operator !=</b> - to know when iterators are not equal to one another</li><li> <b>Pre-Increment Operator ++</b> - to increment the iterator.</li><li> <b>Post-Increment Operator ++</b> - to create and return an incremented iterator.</li></ol><p>And that's it! If these elements are present in a class it is a valid iterator that can be used with STL algorithms. These members must be publically accessible.</p><p>Let's define our iterator in code:<div class='code' >#include&#160;&lt;iterator&gt;<br></br><br></br>template&#160;&lt;class&#160;T&gt;<br></br>class&#160;col_iterator<br></br>{<br></br>&#160;&#160;&#160;&#160;T*&#160;data;<br></br>public:<br></br>&#160;&#160;&#160;&#160;using&#160;iterator_category&#160;=&#160;std::forward_iterator_tag;<br></br>&#160;&#160;&#160;&#160;using&#160;value_type&#160;=&#160;T;<br></br>&#160;&#160;&#160;&#160;using&#160;difference_type&#160;=&#160;size_t;<br></br>&#160;&#160;&#160;&#160;using&#160;pointer&#160;=&#160;T*;<br></br>&#160;&#160;&#160;&#160;using&#160;reference&#160;=&#160;T&;<br></br><br></br>&#160;&#160;&#160;&#160;col_iterator(){}<br></br>&#160;&#160;&#160;&#160;col_iterator(pointer&#160;_data)&#160;:&#160;data(_data)&#160;{}<br></br><br></br>&#160;&#160;&#160;&#160;pointer&#160;data()&#160;{&#160;return&#160;data;&#160;}<br></br>&#160;&#160;&#160;&#160;reference&#160;operator*()&#160;{&#160;return&#160;*data;&#160;}<br></br>&#160;&#160;&#160;&#160;bool&#160;operator!=(const&#160;col_iterator&&#160;other)<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;data&#160;!=&#160;other.data();<br></br>&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&&#160;operator++()<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data&#160;+=&#160;1;<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;*this;<br></br>&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&#160;operator++(int)<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;col_iterator&lt;T&gt;(data&#160;+&#160;1);<br></br>&#160;&#160;&#160;&#160;}<br></br>};<br></br></div><p>As you can see we have defined all the required elements of a <b>Forward Iterator</b>. One thing to note is the member <b>iterator_category</b>. It uses the <b>std::forward_iterator_tag</b> from the standard library marking this iterator as a <b>Forward Iterator</b>. These tags are available in <b>&lt;iterator&gt;</b>.</p><p>Now our class should easily work with STL algorithms such as the following:<div class='code' >Collection&lt;int,&#160;5&gt;&#160;test;<br></br>std::fill(test.begin(),&#160;test.end(),&#160;10);<br></br></div><p>To get more familiar with iterators:</p><ul><li>Add constant iterators to your collection ( define <b>cend()</b> and <b>cbegin()</b>).</li><li>Read up on the different iterator types and their specific requirements.</li><li>Implement different iterator types for your collection.</li><li>Try creating a collection with a different underlying type. For example using a linked-list instead of c-array. The increment and decrement methods will be much different.</li></ul><h2>Complete Code Example</h2><div class='code' >#include&#160;&lt;iterator&gt;<br></br>#include&#160;&lt;iostream&gt;<br></br>#include&#160;&lt;algorithm&gt;<br></br><br></br>template&#160;&lt;class&#160;T&gt;&#160;class&#160;col_iterator;<br></br><br></br>template&lt;class&#160;T,&#160;int&#160;N&gt;<br></br>class&#160;Collection<br></br>{<br></br>&#160;&#160;&#160;&#160;T&#160;data[N]&#160;=&#160;{&#160;0&#160;};<br></br>public:<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&#160;begin()<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;col_iterator&lt;T&gt;(data);<br></br>&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&#160;end()<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;col_iterator&lt;T&gt;(data&#160;+&#160;N);<br></br>&#160;&#160;&#160;&#160;}<br></br>};<br></br><br></br>template&#160;&lt;class&#160;T&gt;<br></br>class&#160;col_iterator<br></br>{<br></br>public:<br></br>&#160;&#160;&#160;&#160;T*&#160;data;<br></br>&#160;&#160;&#160;&#160;using&#160;iterator_category&#160;=&#160;std::forward_iterator_tag;<br></br>&#160;&#160;&#160;&#160;using&#160;value_type&#160;=&#160;T;<br></br>&#160;&#160;&#160;&#160;using&#160;difference_type&#160;=&#160;size_t;<br></br>&#160;&#160;&#160;&#160;using&#160;pointer&#160;=&#160;T*;<br></br>&#160;&#160;&#160;&#160;using&#160;reference&#160;=&#160;T&;<br></br><br></br>&#160;&#160;&#160;&#160;col_iterator(){}<br></br>&#160;&#160;&#160;&#160;col_iterator(pointer&#160;_data)&#160;:&#160;data(_data)&#160;{}<br></br><br></br>&#160;&#160;&#160;&#160;reference&#160;operator*()&#160;{&#160;return&#160;*data;&#160;}<br></br>&#160;&#160;&#160;&#160;bool&#160;operator!=(const&#160;col_iterator&&#160;other)<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;data&#160;!=&#160;other.data;<br></br>&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&&#160;operator++()<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data&#160;+=&#160;1;<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;*this;<br></br>&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;col_iterator&lt;T&gt;&#160;operator++(int)<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;col_iterator&lt;T&gt;(data&#160;+&#160;1);<br></br>&#160;&#160;&#160;&#160;}<br></br>};<br></br><br></br>int&#160;main(void)<br></br>{<br></br>&#160;&#160;&#160;&#160;Collection&lt;int,10&gt;&#160;test;<br></br><br></br>&#160;&#160;&#160;&#160;std::fill(test.begin(),&#160;test.end(),&#160;2);<br></br><br></br>&#160;&#160;&#160;&#160;std::transform(test.begin(),&#160;test.end(),&#160;test.begin(),&#160;[](int&#160;i)<br></br>&#160;&#160;&#160;&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;i&#160;*&#160;i;<br></br>&#160;&#160;&#160;&#160;});<br></br><br></br>&#160;&#160;&#160;&#160;for(auto&#160;t&#160;:&#160;test)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout&#160;&lt;&lt;&#160;t&#160;&lt;&lt;&#160;std::endl;<br></br>}&#160;&#160;&#160;<br></br></div></p></p></blank></content></item><item><title> Cookie-based Session Management</title><link> https://davidgorski.ca/posts/sessions/index.html</link><description> The Bare Necessities of Authentication and Recording User Status</description><content type='html' ><blank><p>Web frameworks had held my hand. Which for a beginner was great, but a lot of the fundamental aspects of back-end development had been abstracted from me, and I found annoying discrepancies between my knowledge and know-how. Sessions were one element I had neglected. I had taken them for granted; somehow magically some level of state is maintained between the server and the client.</p><p>It wasn't till I started writing my <a href='https://github.com/dgski/baseketbase-agg' >News Aggregator</a> Project in <a href='https://racket-lang.org' >Racket</a> that I realized I don't really know how sessions work. Racket's a great language, but it's not exactly popular and doesn't have any web frameworks. I needed to learn and write my own session manager. So I did.</p><p>How exactly does the server know whether a given client is logged in? Turns out it's mainly about <b>cookies</b>. Cookies are small collections of data that the server asks the client to store. They are transmitted in the HTTP request headers under the <b>Cookie</b> section, and held by the browser on the client's end. </p><p>For sessions, the server generates a session id, tells the client to remember it, the client does so and attaches that sid to following requests, so the server knows whether a request belongs to an authenticated session or not.</p><p>To better understand how this works; let's write a simple HTTP request handler. We will use the basic web server provided in python's <b>http.server</b> package. </p><p>We will start with three elements:</p><ul><li>address: this is the address and port at which the server will listen for connections</li><li>handler: this is a class which has the necessary methods to handle requests</li><li>server: we will initialize the built-in <b>HTTPServer</b> object with our address and handler.</li></ul><p>Finally, we will start our server using the <b>serve_forever()</b> method:</p><div class='code' >from&#160;http.server&#160;import&#160;*<br></br><br></br>#Setup<br></br>address&#160;=&#160;('',&#160;8000)<br></br>handler&#160;=&#160;BaseHTTPRequestHandler<br></br>server&#160;=&#160;HTTPServer(address,&#160;handler)<br></br><br></br>#Start<br></br>server.serve_forever()<br></br></div><p>We can send a request to our new server using a browser at <b>localhost:8000</b>. However, we should still the following error:</p><div class='code' >Error&#160;response<br></br><br></br>Error&#160;code:&#160;501<br></br><br></br>Message:&#160;Unsupported&#160;method&#160;('GET').<br></br><br></br>Error&#160;code&#160;explanation:&#160;HTTPStatus.NOT_IMPLEMENTED&#160;-<br></br>Server&#160;does&#160;not&#160;support&#160;this&#160;operation.<br></br></div><p>Looks like our handler can't handle simple <b>GET</b> requests... We need to do something about that. Define a new class at the top of the file. We still use <b>BaseHTTPRequestHandler</b> as the parent class, but add the <b>do_GET()</b> method:</p><div class='code' ><br></br>class&#160;SessionHandler(BaseHTTPRequestHandler):<br></br>&#160;&#160;&#160;&#160;def&#160;do_GET(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.response&#160;=&#160;200<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.send_header('Content-type','text/html')<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content&#160;=&#160;"Hello"<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.wfile.write(bytes(content,&#160;"utf-8"))<br></br><br></br></div><p>Remember to change the handler to our new class:</p><div class='code' >handler&#160;=&#160;SessionHandler<br></br></div><h2>Dispatching</h2><p>Now if you visit again with your browser, you should now see the raw text, "Hello" displayed. That's a good start, but we need our server to do different things based on different URL paths. Let's add a simple dispatcher and methods to handle the paths:</p><div class='code' >class&#160;SessionHandler(BaseHTTPRequestHandler):<br></br>&#160;&#160;&#160;&#160;def&#160;do_GET(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;routes&#160;=&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"/login":&#160;&#160;&#160;self.login,<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"/logout":&#160;&#160;self.logout,<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"/":&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.home<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;response&#160;=&#160;200<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content&#160;=&#160;routes[self.path]()<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;except:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;response&#160;=&#160;404<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content&#160;=&#160;"Not&#160;Found"<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.send_response(response)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.send_header('Content-type','text/html')<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.end_headers()<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.wfile.write(bytes(content,&#160;"utf-8"))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return<br></br>&#160;&#160;&#160;&#160;<br></br>&#160;&#160;&#160;&#160;def&#160;home(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Welcome&#160;Home"<br></br><br></br>&#160;&#160;&#160;&#160;def&#160;login(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#&#160;todo:&#160;perform&#160;login<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Logged&#160;In"<br></br><br></br>&#160;&#160;&#160;&#160;def&#160;logout(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#&#160;todo:&#160;perform&#160;logout<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Logged&#160;Out"<br></br></div><p>Okay, things are taking shape. Let's run through what was added:</p><ul><li>The <b>routes</b> dictionary has paths as keys and page methods as values.</li><li>We use the <b>try,except</b> statement to try to access the methods using the path. If it works, we set <b>response</b> to 200 (success) and prepare our content. Otherwise, we set <b>response</b> to 404 (not found) and set content to <b>Not Found</b>.</li><li>The home, login and logout methods return a text string representing themselves.</li></ul><h2>Logging In</h2><p>Now let's implement our login process. After a user logs in, the time spent logged in is referred to as a <b>session</b>. For each login and consecutive logout, we will have a unique session id (sid). So obviously, our next immediate step is to generate a new <b>sid</b> when the user clicks on login. We will use a dictionary to store our sessions ids. Usually a database fulfills this role, but for our simple purposes, this should be enough. For incredibly basic security import the randint function:</p><div class='code' >from&#160;random&#160;import&#160;randint<br></br></div><p>Add the following method to generate the sid:</p><div class='code' >def&#160;generate_sid(self):<br></br>&#160;&#160;&#160;&#160;return&#160;"".join(str(randint(1,9))&#160;for&#160;_&#160;in&#160;range(100))<br></br></div><p>Add a global dictionary to the top of the file:</p><div class='code' >sessions&#160;=&#160;{}<br></br></div><p>Make the following changes to the <b>login</b> method:<div class='code' >def&#160;login(self):<br></br>&#160;&#160;&#160;&#160;#&#160;Password&#160;normally&#160;be&#160;checked&#160;here<br></br>&#160;&#160;&#160;&#160;sid&#160;=&#160;self.generate_sid()<br></br>&#160;&#160;&#160;&#160;self.cookie&#160;=&#160;"sid={}".format(sid)<br></br>&#160;&#160;&#160;&#160;sessions[sid]&#160;=&#160;{"username",&#160;"useragent","ip&#160;address","expiry"}<br></br>&#160;&#160;&#160;&#160;return&#160;"Logged&#160;In"<br></br></div><p>Add the following <b>send_header</b> function calls to bottom of the <b>do_GET</b> method:<div class='code' >def&#160;do_GET(self):&#160;<br></br>&#160;&#160;&#160;&#160;#...<br></br>&#160;&#160;&#160;&#160;self.cookie&#160;=&#160;None&#160;#&#160;Addition<br></br>&#160;&#160;&#160;&#160;self.send_response(response)<br></br>&#160;&#160;&#160;&#160;self.send_header('Content-type','text/html')<br></br>&#160;&#160;&#160;&#160;if&#160;self.cookie:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.send_header('Set-Cookie',&#160;self.cookie)&#160;#&#160;Addition<br></br>&#160;&#160;&#160;&#160;self.end_headers()<br></br>&#160;&#160;&#160;&#160;self.wfile.write(bytes(content,&#160;"utf-8"))<br></br>&#160;&#160;&#160;&#160;return<br></br></div><p>What is happening should be clear: <b>login()</b> is setting the <b>self.cookie</b> member variable to a random string of numbers, and <b>self.send_header('Set-Cookie', self.cookie)</b> is sending it off as a cookie value. Now if you visit <b>/login</b> in your browser, and open up the web inspector, you should see <b>sid</b> as a cookie, with the value as whatever you generated. This cookie is held by the browser, and will be forwarded to our server with every request. It provides 'context' between requests.</p><p>Also, notice that <b>login()</b> adds the sid to the dictionary as a key with a dummy dictionary <b>{"username", "useragent","ip address","expiry"}</b> as a value. This is where a complete session manager would store those pieces of information about the user, to later verify the session. Add this on your own.</p><h2>Validating users</h2><p>Now we need to perform the most fundamental aspect of session management: validating a session. Let's say there is some content that only registered, logged in users can see. We don't want our user to have to provide their password with each page request; That would be incredibly cumbersome. We need to check if a request contains a session and display the right thing. We need to extract a header's sid to get that information. Add the following method to our <b>SessionHandler</b> class:</p><div class='code' >def&#160;parse_cookies(self,&#160;cookie_list):<br></br>&#160;&#160;&#160;&#160;return&#160;dict(((c.split("="))&#160;for&#160;c&#160;in&#160;cookie_list.split(";")))&#160;if&#160;cookie_list&#160;else&#160;{}<br></br></div><p>This will nicely extract the cookies string from the request and put it into a dictionary for our convenience. Also alter our <b>do_GET</b> <b>try</b> block so it looks like this:</p><div class='code' >try:<br></br>&#160;&#160;&#160;&#160;response&#160;=&#160;200<br></br>&#160;&#160;&#160;&#160;cookies&#160;=&#160;self.parse_cookies(self.headers["Cookie"])<br></br>&#160;&#160;&#160;&#160;if&#160;"sid"&#160;in&#160;cookies:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.user&#160;=&#160;cookies["sid"]&#160;if&#160;(cookies["sid"]&#160;in&#160;sessions)&#160;else&#160;False<br></br>&#160;&#160;&#160;&#160;else:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.user&#160;=&#160;False<br></br>&#160;&#160;&#160;&#160;content&#160;=&#160;routes[self.path]()<br></br></div><p>Our home page should display whether a user is currently logged in:<div class='code' >def&#160;home(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Welcome&#160;User!"&#160;if&#160;self.user&#160;else&#160;"Welcome&#160;Stranger!"<br></br></div><p>What is happening here? Take a closer look at the try block. There are a few interesting things happening within:</p><ul><li>As before, we are setting the response to code 200, which for a HTTP request, it means that the page was found</li><li>Secondly, we are parsing the <b>Cookie</b> section of the header. Our <b>parse_cookies</b> method splits the Cookie string by ";" to seperate the individual cookies, then it puts the cookie ids and their values into a dictionary. If there are no cookies, it responds with an empty dictionary</li><li>Next, our try block checks if "sid" is in the <b>cookies</b> dictionary. If it isn't, it sets <b>self.user</b> to false. Otherwise, it then checks whether the sid value stored in the <b>sessions</b> global.</li><li>From then on, it's business as usual.</li></ul><p>We have altered a fundamental behaviour of our micro-program: when we visit the homepage without a generated sid cookie being broadcast by the browser we will see:<div class='code' >"Welcome&#160;Stranger!"<br></br></div><p>Clearly, unless the sid is stored in the <b>sessions</b> dictionary, the application instance does not recognize the web user. But if the user logs in using the rudimentary <b>/login</b> page, it will display:<div class='code' >"Welcome&#160;User!"<br></br></div><p>Try logging in, and then restarting our server. If you return to the home page, it won't recognize you, even if the browser holds and sends a <b>sid</b> cookie. Because the dictionary dies with the process, our server completely forgets about the session. If you visit the <b>login</b> page again, a new <b>sid</b> is generated, and we get <b>"Welcome User!"</b>.</p><p>To Recap: the login process generates a new sid, saves the users information(user agent, ip address, etc), and sends back a header asking for the user's browser to remember the new sid. Of course to be useful in most cases,  you would have to validate a login password before generating the sid and continuing, but the fundamental aspects of session management are already present.</p><h2>Logging Out</h2><p>What if the user wants to end their session? Well, we should probably give them a log out page as well. Let's add something to our currently useless logout page:<div class='code' >&#160;&#160;&#160;&#160;def&#160;logout(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;not&#160;self.user:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Can't&#160;Log&#160;Out:&#160;No&#160;User&#160;Logged&#160;In"<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.cookie&#160;=&#160;"sid="<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;del&#160;sessions[self.user]<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Logged&#160;Out"<br></br></div><p>This method will check if a valid user is logged in, set the cookie to empty and delete the session id from the <b>sessions</b> dictionary, before returning the <b>"Logged Out"</b> text.</p><p>Check out what happens now: restart our your server application, open it and validate the following happens in order:</p><ol><li> On First Visit of the home page <b>"/"</b> it should display: "Welcome Stranger!".</li><li> If you now visit <b>"/login"</b>, it should display "Logged In", check your cookies for the "/" domain, you should see an <b>sid</b> cookie with the newly generated session.</li><li> Now if you visit the home page, your should see: "Welcome User!". Congratulations, your session has been validated!</li><li> Next test if the <b>"/logout"</b> page works. Visit it, it should say "Logged Out". Make sure it worked by once again checking your cookies in your browser. The <b>sid</b> cookie should be empty.</li><li> If you visit the home page again, it should display: "Welcome Stranger!". You have successfully logged out.</li></ol><p>The complete code should now look like:<div class='code' >from&#160;http.server&#160;import&#160;*<br></br>from&#160;random&#160;import&#160;randint<br></br><br></br>sessions&#160;=&#160;{}<br></br><br></br>class&#160;SessionHandler(BaseHTTPRequestHandler):<br></br>&#160;&#160;&#160;&#160;def&#160;do_GET(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;routes&#160;=&#160;{<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"/login":&#160;self.login,<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"/logout":&#160;self.logout,<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"/":&#160;self.home<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.cookie&#160;=&#160;None<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;response&#160;=&#160;200<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cookies&#160;=&#160;self.parse_cookies(self.headers["Cookie"])<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;"sid"&#160;in&#160;cookies:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.user&#160;=&#160;cookies["sid"]&#160;if&#160;(cookies["sid"]&#160;in&#160;sessions)&#160;else&#160;False<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.user&#160;=&#160;False<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content&#160;=&#160;routes[self.path]()<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;except:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;response&#160;=&#160;404<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content&#160;=&#160;"Not&#160;Found"<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.send_response(response)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.send_header('Content-type','text/html')<br></br><br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;self.cookie:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.send_header('Set-Cookie',&#160;self.cookie)<br></br><br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.end_headers()<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.wfile.write(bytes(content,&#160;"utf-8"))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return<br></br>&#160;&#160;&#160;&#160;<br></br>&#160;&#160;&#160;&#160;def&#160;home(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Welcome&#160;User!"&#160;if&#160;self.user&#160;else&#160;"Welcome&#160;Stranger!"<br></br><br></br>&#160;&#160;&#160;&#160;def&#160;login(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;#&#160;Password&#160;would&#160;normally&#160;be&#160;checked&#160;here<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sid&#160;=&#160;self.generate_sid()<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.cookie&#160;=&#160;"sid={}".format(sid)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sessions[sid]&#160;=&#160;{"username",&#160;"useragent","ip&#160;address","expiry"}<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Logged&#160;In"<br></br><br></br>&#160;&#160;&#160;&#160;def&#160;logout(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;not&#160;self.user:<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Can't&#160;Log&#160;Out:&#160;No&#160;User&#160;Logged&#160;In"<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.cookie&#160;=&#160;"sid="<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;del&#160;sessions[self.user]<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"Logged&#160;Out"<br></br><br></br>&#160;&#160;&#160;&#160;def&#160;generate_sid(self):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;"".join(str(randint(1,9))&#160;for&#160;_&#160;in&#160;range(100))<br></br><br></br>&#160;&#160;&#160;&#160;def&#160;parse_cookies(self,&#160;cookie_list):<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;dict(((c.split("="))&#160;for&#160;c&#160;in&#160;cookie_list.split(";")))&#160;\<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;cookie_list&#160;else&#160;{}<br></br><br></br>address&#160;=&#160;('',&#160;8000)<br></br>handler&#160;=&#160;SessionHandler<br></br>server&#160;=&#160;HTTPServer(address,&#160;handler)<br></br><br></br>server.serve_forever()<br></br></div><p>Please read more about cookies, their expiration setting, and elements of session security before deploying anything like this. There are many more standard practices to consider; including encrypting the session id. Stay Safe!</p></p></p></p></p></p></p></p></blank></content></item><item><title> Collector Functions in Scheme</title><link> https://davidgorski.ca/posts/collectors-in-scheme/index.html</link><description> Building and Passing Lambda Sandwiches</description><content type='html' ><blank><p>The Collector paradigm is a functional way of assembling and processing collections of data. As a design pattern it also offers a few benefits, and at the very least provides a unique academic exercise.</p><p>I've recently been working through the classic book; <a href='https://www.goodreads.com/book/show/548914.The_Little_Schemer' >The Little Schemer</a>, which is a cute and concise introduction to Scheme. The Chapter covering this topic delivered the first real friction, so I took some time to chew through it, understand it, and expand its explanation.</p><p>Let's start by defining a function which takes a list of numbers, and uses the collector paradigm to sort the numbers into two categories, Odd and Even:</p><div class='code' >(define&#160;sep-odds<br></br>&#160;&#160;(lambda&#160;(lat&#160;col)<br></br>&#160;&#160;&#160;&#160;(cond<br></br>&#160;&#160;&#160;&#160;&#160;&#160;((null?&#160;lat)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(col&#160;'()&#160;'()))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;((=&#160;(modulo&#160;(car&#160;lat)&#160;2)&#160;0)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(sep-odds&#160;(cdr&#160;lat)&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(col&#160;odds&#160;(cons&#160;(car&#160;lat)&#160;evens)))))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(else<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(sep-odds&#160;(cdr&#160;lat)&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(col&#160;(cons&#160;(car&#160;lat)&#160;odds)&#160;evens)))))))<br></br></div><p>This function will consume two arguments: a list of numbers (lat) and a collector function (col). Its body consist's of one <b>cond</b> statement with 3 branches:</p><table><tr><th>Branch                       </th><th> Description</th></tr><tr><td>(null? lat)                  </td><td> Checks if <b>lat</b> is empty</td></tr><tr><td>(= (modulo (car lat) 2) 0)   </td><td> Checks if the first entry in the list is even</td></tr><tr><td>else                         </td><td> Concludes first list entry must be odd</td></tr></table><p>Take a note as to how <b>sep-odds</b> recurs: It does not build a list in the simple way of functionally building up a collection. Instead, if <b>sep-odds</b> is to recur it builds a lambda function which will perform a particular task (in this case using <b>cons</b> to prepend the number to one of the lists) and then passes this lambda function to the next call of <b>sep-odds</b> as the <b>col</b> argument.</p><p>Wrapping a task in a lambda is a neat trick: It delays execution of the wrapped code until the lambda is called.</p><p>Another neat trick is that <b>sep-odds</b> stuffs the previous collector function (bound to <b>col</b> as a function parameter) into the new lambda's body. I like to visualize this as a sandwich, with previous collectors being stuffed inside new ones. Finally, when one of these lambdas is called, it does its work, and then calls the collector function embedded inside it.</p><p>For our <b>sep-odds</b> function, you may notice that we need to provide an initial collector. Let's get to it.</p><p><b>First Time with Scheme?</b> <i>Please Note: (car x) returns the first element of the list x, and (cdr x) returns list x excluding the first element.</i></p><p>We will define <b>list</b> as our 0th collector. This will be the very centre of the lambda function sandwich:</p><div class='code' >(define&#160;col-0&#160;list)<br></br></div><p>Now let's step through what happens when we perform the following function call:</p><div class='code' >(sep-odds&#160;'(1&#160;2&#160;3&#160;4)&#160;col-0)&#160;;&#160;return&#160;value&#160;-&gt;&#160;((1&#160;3)&#160;(2&#160;4))<br></br></div><p><b>(car lat)</b> for the first call of sep-odds is <b>1</b>, therefore the third condition (<b>else</b>) is matched. This will generate a new lambda with <b>col-0</b> as <b>col</b> and <b>1 (car lat)</b> inside it. For clarity, we will label this newly generated lambda function as <b>col-1</b>:</p><div class='code' >;&#160;consumes&#160;two&#160;lists&#160;(odds&#160;and&#160;evens)&#160;and&#160;adds&#160;1&#160;to&#160;the&#160;odds&#160;list<br></br>(define&#160;col-1<br></br>&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;(col-0&#160;(cons&#160;1&#160;odds)&#160;evens)))<br></br></div><p>This conditional branch will then call sep-odds again, with the rest of the list <b>(cdr lat)</b> and the newly-generated <b>col-1</b> as arguments:</p><div class='code' >(sep-odds&#160;'(2&#160;3&#160;4)&#160;col-1)<br></br></div><p>After this second function call the second conditional branch <b>(= (modulo (car lat) 2) 0)</b> is triggered as 2 is an even number. Same story again: a new lambda is built, but this time <b>col-1</b> is bound to <b>col</b>:</p><div class='code' >;&#160;consumes&#160;two&#160;lists&#160;(odds&#160;and&#160;evens)&#160;and&#160;adds&#160;2&#160;to&#160;the&#160;evens&#160;list<br></br>(define&#160;col-2<br></br>&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;(col-1&#160;odds&#160;(cons&#160;2&#160;evens))))<br></br></div><p>Now <b>col-2</b> and the remainder of the list will serve as the arguments for the <b>sep-odds</b> recursive call:</p><div class='code' >(sep-odds&#160;'(3&#160;4)&#160;col-2)<br></br></div><p>We repeat, again with an odd number (<b>3</b>):</p><div class='code' >;&#160;consumes&#160;two&#160;lists&#160;(odds&#160;and&#160;evens)&#160;and&#160;adds&#160;3&#160;to&#160;the&#160;odds&#160;list<br></br>(define&#160;col-3<br></br>&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;(col-2&#160;(cons&#160;3&#160;odds)&#160;evens)))<br></br></div><p>and our next call:</p><div class='code' >(sep-odds&#160;'(4)&#160;col-3)<br></br></div><p>Again, with an even number (<b>4</b>):</p><div class='code' >;&#160;consumes&#160;two&#160;lists&#160;(odds&#160;and&#160;evens)&#160;and&#160;adds&#160;4&#160;to&#160;the&#160;evens&#160;list<br></br>(define&#160;col-4<br></br>&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;(col-3&#160;odds&#160;(cons&#160;4&#160;evens))))<br></br></div><p>Finally, since the input list is empty, the <b>null?</b> conditional is triggered with this final call:</p><div class='code' >(sep-odds&#160;'()&#160;col-4)<br></br></div><p>That <b>null?</b> conditional applies the <b>col</b> function. In this case it is our latest, <b>col-4</b>:</p><div class='code' >;&#160;excerpt:<br></br>((null?&#160;lat)&#160;(col-4&#160;'()&#160;'()))<br></br></div><p>At this moment our sandwich is at its juiciest. Each layer takes an input from the previous one, as the layers are stripped away. We will begin with the outside 'bun' of the sandwich and go inwards. Each collector function calls the collector embedded within it:</p><div class='code' >(define&#160;col-4<br></br>&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;(col-3&#160;odds&#160;(cons&#160;4&#160;evens))))<br></br>;&#160;&#160;&#160;|____|<br></br>;&#160;&#160;&#160;&#160;&#160;|<br></br>;&#160;&#160;&#160;&#160;&#160;|<br></br>&#160;&#160;&#160;&#160;&#160;&#160;(define&#160;col-3<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(col-2&#160;(cons&#160;3&#160;odds)&#160;evens)))<br></br>;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|____|<br></br>;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br></br>;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(define&#160;col-2<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(col-1&#160;odds&#160;(cons&#160;2&#160;evens))))<br></br>;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|____|<br></br>;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br></br>;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(define&#160;col-1<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(col-0&#160;(cons&#160;1&#160;odds)&#160;evens)))<br></br><br></br></div><p>We are lucky we used labels, In reality the lambda generated looks like this:</p><div class='code' >(lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;((lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((lambda&#160;(odds&#160;evens)<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(col-0&#160;(cons&#160;1&#160;odds)&#160;evens))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;odds&#160;(cons&#160;2&#160;evens)))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(cons&#160;3&#160;odds)&#160;evens))<br></br>&#160;&#160;&#160;&#160;&#160;&#160;odds&#160;(cons&#160;4&#160;evens)))<br></br></div><p>And this is how the function calls look with the computed values of the arguments:</p><div class='code' >1.&#160;(col-4&#160;'()&#160;'())<br></br>2.&#160;(col-3&#160;'()&#160;'(4))<br></br>3.&#160;(col-2&#160;'(3)&#160;'(4))<br></br>4.&#160;(col-1&#160;'(3)&#160;'(2&#160;4))<br></br>5.&#160;(col-0&#160;'(1&#160;3)&#160;'(2&#160;4))<br></br>6.&#160;(list&#160;'(1&#160;3)&#160;'(2&#160;4))<br></br>7.&#160;((1&#160;3)&#160;(2&#160;4))<br></br></div><p>All of these expressions have the same value.</p><p>So now the big question: Why? Why complicate things like this? Why not just use multiple lists as arguments to gather the data we want?</p><p>Well, Collector functions offer two advantages: Delayed Execution, and Continuations.</p><p>To address the first point, in this example, each generated lambda is doing something relatively inexpensive: using <b>cons</b> to prepend a number to a list. But what if it was performing some sort of expensive operation? For example: performing operations on a matrix with massive proportions, or rendering graphics. Perhaps there is hypothetical example where we do not want to do anything computationally expensive until the data input has been completely verified, from start to finish? In that case a collector paradigm would work well. Building the collector works sort of as a type of manifest or queue, of operations to be performed.</p><p>Secondly, if you have a function which represents a series of steps, and each step has their own state, you can travel back to these states. In effect, you save a snapshot of that point in time. And in Scheme, since you can pass function along; you can pass these snapshots around. This gives you flexibility to return back to times where data was valid or matched some sort of pattern. One thing that comes to mind is traversing a Tree data structure and if you are exploring the children of a branch, you can pass forward a collector that represents that root, until you reach something you need and feed that data into the collector.</p></blank></content></item></channel></rss>