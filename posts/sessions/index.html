
    <!doctype html>
    <html>
        <head>
            <title> Cookie-based Session Management</title>
            <link rel="stylesheet" type="text/css" href="/style.css">
        </head>
        <body>
            
            <div class="post-content">
                <h1 class="post-title"> Cookie-based Session Management</h1>
                <em> The Bare Necessities of Authentication and Recording User Status</em>
                <div class="post-body">
                    <blank><p>Web frameworks had held my hand. Which for a beginner was great, but a lot of the fundamental aspects of back-end development had been abstracted from me, and I found annoying discrepancies between my knowledge and know-how. Sessions were one element I had neglected. I had taken them for granted; somehow magically some level of state is maintained between the server and the client.</p><p>It wasn't till I started writing my <a href='https://github.com/dgski/baseketbase-agg' >News Aggregator</a> Project in <a href='https://racket-lang.org' >Racket</a> that I realized I don't really know how sessions work. Racket's a great language, but it's not exactly popular and doesn't have any web frameworks. I needed to learn and write my own session manager. So I did.</p><p>How exactly does the server know whether a given client is logged in? Turns out it's mainly about <b>cookies</b>. Cookies are small collections of data that the server asks the client to store. They are transmitted in the HTTP request headers under the <b>Cookie</b> section, and held by the browser on the client's end. </p><p>For sessions, the server generates a session id, tells the client to remember it, the client does so and attaches that sid to following requests, so the server knows whether a request belongs to an authenticated session or not.</p><p>To better understand how this works; let's write a simple HTTP request handler. We will use the basic web server provided in python's <b>http.server</b> package. </p><p>We will start with three elements:</p><ul><li>address: this is the address and port at which the server will listen for connections</li><li>handler: this is a class which has the necessary methods to handle requests</li><li>server: we will initialize the built-in <b>HTTPServer</b> object with our address and handler.</li></ul><p>Finally, we will start our server using the <b>serve_forever()</b> method:</p><div class='code' >from&nbsp;http.server&nbsp;import&nbsp;*<br><br>#Setup<br>address&nbsp;=&nbsp;('',&nbsp;8000)<br>handler&nbsp;=&nbsp;BaseHTTPRequestHandler<br>server&nbsp;=&nbsp;HTTPServer(address,&nbsp;handler)<br><br>#Start<br>server.serve_forever()<br></div><p>We can send a request to our new server using a browser at <b>localhost:8000</b>. However, we should still the following error:</p><div class='code' >Error&nbsp;response<br><br>Error&nbsp;code:&nbsp;501<br><br>Message:&nbsp;Unsupported&nbsp;method&nbsp;('GET').<br><br>Error&nbsp;code&nbsp;explanation:&nbsp;HTTPStatus.NOT_IMPLEMENTED&nbsp;-<br>Server&nbsp;does&nbsp;not&nbsp;support&nbsp;this&nbsp;operation.<br></div><p>Looks like our handler can't handle simple <b>GET</b> requests... We need to do something about that. Define a new class at the top of the file. We still use <b>BaseHTTPRequestHandler</b> as the parent class, but add the <b>do_GET()</b> method:</p><div class='code' ><br>class&nbsp;SessionHandler(BaseHTTPRequestHandler):<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_GET(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;"Hello"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br><br></div><p>Remember to change the handler to our new class:</p><div class='code' >handler&nbsp;=&nbsp;SessionHandler<br></div><h2>Dispatching</h2><p>Now if you visit again with your browser, you should now see the raw text, "Hello" displayed. That's a good start, but we need our server to do different things based on different URL paths. Let's add a simple dispatcher and methods to handle the paths:</p><div class='code' >class&nbsp;SessionHandler(BaseHTTPRequestHandler):<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_GET(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/login":&nbsp;&nbsp;&nbsp;self.login,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/logout":&nbsp;&nbsp;self.logout,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.home<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;routes[self.path]()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;404<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;"Not&nbsp;Found"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_response(response)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.end_headers()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;home(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Welcome&nbsp;Home"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;login(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;todo:&nbsp;perform&nbsp;login<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;In"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;logout(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;todo:&nbsp;perform&nbsp;logout<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;Out"<br></div><p>Okay, things are taking shape. Let's run through what was added:</p><ul><li>The <b>routes</b> dictionary has paths as keys and page methods as values.</li><li>We use the <b>try,except</b> statement to try to access the methods using the path. If it works, we set <b>response</b> to 200 (success) and prepare our content. Otherwise, we set <b>response</b> to 404 (not found) and set content to <b>Not Found</b>.</li><li>The home, login and logout methods return a text string representing themselves.</li></ul><h2>Logging In</h2><p>Now let's implement our login process. After a user logs in, the time spent logged in is referred to as a <b>session</b>. For each login and consecutive logout, we will have a unique session id (sid). So obviously, our next immediate step is to generate a new <b>sid</b> when the user clicks on login. We will use a dictionary to store our sessions ids. Usually a database fulfills this role, but for our simple purposes, this should be enough. For incredibly basic security import the randint function:</p><div class='code' >from&nbsp;random&nbsp;import&nbsp;randint<br></div><p>Add the following method to generate the sid:</p><div class='code' >def&nbsp;generate_sid(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"".join(str(randint(1,9))&nbsp;for&nbsp;_&nbsp;in&nbsp;range(100))<br></div><p>Add a global dictionary to the top of the file:</p><div class='code' >sessions&nbsp;=&nbsp;{}<br></div><p>Make the following changes to the <b>login</b> method:<div class='code' >def&nbsp;login(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Password&nbsp;normally&nbsp;be&nbsp;checked&nbsp;here<br>&nbsp;&nbsp;&nbsp;&nbsp;sid&nbsp;=&nbsp;self.generate_sid()<br>&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid={}".format(sid)<br>&nbsp;&nbsp;&nbsp;&nbsp;sessions[sid]&nbsp;=&nbsp;{"username",&nbsp;"useragent","ip&nbsp;address","expiry"}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;In"<br></div><p>Add the following <b>send_header</b> function calls to bottom of the <b>do_GET</b> method:<div class='code' >def&nbsp;do_GET(self):&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;#...<br>&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;None&nbsp;#&nbsp;Addition<br>&nbsp;&nbsp;&nbsp;&nbsp;self.send_response(response)<br>&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.cookie:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Set-Cookie',&nbsp;self.cookie)&nbsp;#&nbsp;Addition<br>&nbsp;&nbsp;&nbsp;&nbsp;self.end_headers()<br>&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br>&nbsp;&nbsp;&nbsp;&nbsp;return<br></div><p>What is happening should be clear: <b>login()</b> is setting the <b>self.cookie</b> member variable to a random string of numbers, and <b>self.send_header('Set-Cookie', self.cookie)</b> is sending it off as a cookie value. Now if you visit <b>/login</b> in your browser, and open up the web inspector, you should see <b>sid</b> as a cookie, with the value as whatever you generated. This cookie is held by the browser, and will be forwarded to our server with every request. It provides 'context' between requests.</p><p>Also, notice that <b>login()</b> adds the sid to the dictionary as a key with a dummy dictionary <b>{"username", "useragent","ip address","expiry"}</b> as a value. This is where a complete session manager would store those pieces of information about the user, to later verify the session. Add this on your own.</p><h2>Validating users</h2><p>Now we need to perform the most fundamental aspect of session management: validating a session. Let's say there is some content that only registered, logged in users can see. We don't want our user to have to provide their password with each page request; That would be incredibly cumbersome. We need to check if a request contains a session and display the right thing. We need to extract a header's sid to get that information. Add the following method to our <b>SessionHandler</b> class:</p><div class='code' >def&nbsp;parse_cookies(self,&nbsp;cookie_list):<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dict(((c.split("="))&nbsp;for&nbsp;c&nbsp;in&nbsp;cookie_list.split(";")))&nbsp;if&nbsp;cookie_list&nbsp;else&nbsp;{}<br></div><p>This will nicely extract the cookies string from the request and put it into a dictionary for our convenience. Also alter our <b>do_GET</b> <b>try</b> block so it looks like this:</p><div class='code' >try:<br>&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;cookies&nbsp;=&nbsp;self.parse_cookies(self.headers["Cookie"])<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;"sid"&nbsp;in&nbsp;cookies:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;cookies["sid"]&nbsp;if&nbsp;(cookies["sid"]&nbsp;in&nbsp;sessions)&nbsp;else&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;routes[self.path]()<br></div><p>Our home page should display whether a user is currently logged in:<div class='code' >def&nbsp;home(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Welcome&nbsp;User!"&nbsp;if&nbsp;self.user&nbsp;else&nbsp;"Welcome&nbsp;Stranger!"<br></div><p>What is happening here? Take a closer look at the try block. There are a few interesting things happening within:</p><ul><li>As before, we are setting the response to code 200, which for a HTTP request, it means that the page was found</li><li>Secondly, we are parsing the <b>Cookie</b> section of the header. Our <b>parse_cookies</b> method splits the Cookie string by ";" to seperate the individual cookies, then it puts the cookie ids and their values into a dictionary. If there are no cookies, it responds with an empty dictionary</li><li>Next, our try block checks if "sid" is in the <b>cookies</b> dictionary. If it isn't, it sets <b>self.user</b> to false. Otherwise, it then checks whether the sid value stored in the <b>sessions</b> global.</li><li>From then on, it's business as usual.</li></ul><p>We have altered a fundamental behaviour of our micro-program: when we visit the homepage without a generated sid cookie being broadcast by the browser we will see:<div class='code' >"Welcome&nbsp;Stranger!"<br></div><p>Clearly, unless the sid is stored in the <b>sessions</b> dictionary, the application instance does not recognize the web user. But if the user logs in using the rudimentary <b>/login</b> page, it will display:<div class='code' >"Welcome&nbsp;User!"<br></div><p>Try logging in, and then restarting our server. If you return to the home page, it won't recognize you, even if the browser holds and sends a <b>sid</b> cookie. Because the dictionary dies with the process, our server completely forgets about the session. If you visit the <b>login</b> page again, a new <b>sid</b> is generated, and we get <b>"Welcome User!"</b>.</p><p>To Recap: the login process generates a new sid, saves the users information(user agent, ip address, etc), and sends back a header asking for the user's browser to remember the new sid. Of course to be useful in most cases,  you would have to validate a login password before generating the sid and continuing, but the fundamental aspects of session management are already present.</p><h2>Logging Out</h2><p>What if the user wants to end their session? Well, we should probably give them a log out page as well. Let's add something to our currently useless logout page:<div class='code' >&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;logout(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;self.user:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Can't&nbsp;Log&nbsp;Out:&nbsp;No&nbsp;User&nbsp;Logged&nbsp;In"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid="<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;del&nbsp;sessions[self.user]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;Out"<br></div><p>This method will check if a valid user is logged in, set the cookie to empty and delete the session id from the <b>sessions</b> dictionary, before returning the <b>"Logged Out"</b> text.</p><p>Check out what happens now: restart our your server application, open it and validate the following happens in order:</p><ol><li> On First Visit of the home page <b>"/"</b> it should display: "Welcome Stranger!".</li><li> If you now visit <b>"/login"</b>, it should display "Logged In", check your cookies for the "/" domain, you should see an <b>sid</b> cookie with the newly generated session.</li><li> Now if you visit the home page, your should see: "Welcome User!". Congratulations, your session has been validated!</li><li> Next test if the <b>"/logout"</b> page works. Visit it, it should say "Logged Out". Make sure it worked by once again checking your cookies in your browser. The <b>sid</b> cookie should be empty.</li><li> If you visit the home page again, it should display: "Welcome Stranger!". You have successfully logged out.</li></ol><p>The complete code should now look like:<div class='code' >from&nbsp;http.server&nbsp;import&nbsp;*<br>from&nbsp;random&nbsp;import&nbsp;randint<br><br>sessions&nbsp;=&nbsp;{}<br><br>class&nbsp;SessionHandler(BaseHTTPRequestHandler):<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_GET(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routes&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/login":&nbsp;self.login,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/logout":&nbsp;self.logout,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/":&nbsp;self.home<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;None<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cookies&nbsp;=&nbsp;self.parse_cookies(self.headers["Cookie"])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;"sid"&nbsp;in&nbsp;cookies:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;cookies["sid"]&nbsp;if&nbsp;(cookies["sid"]&nbsp;in&nbsp;sessions)&nbsp;else&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.user&nbsp;=&nbsp;False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;routes[self.path]()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response&nbsp;=&nbsp;404<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;"Not&nbsp;Found"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_response(response)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Content-type','text/html')<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;self.cookie:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.send_header('Set-Cookie',&nbsp;self.cookie)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.end_headers()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.wfile.write(bytes(content,&nbsp;"utf-8"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;home(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Welcome&nbsp;User!"&nbsp;if&nbsp;self.user&nbsp;else&nbsp;"Welcome&nbsp;Stranger!"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;login(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Password&nbsp;would&nbsp;normally&nbsp;be&nbsp;checked&nbsp;here<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sid&nbsp;=&nbsp;self.generate_sid()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid={}".format(sid)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sessions[sid]&nbsp;=&nbsp;{"username",&nbsp;"useragent","ip&nbsp;address","expiry"}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;In"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;logout(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;self.user:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Can't&nbsp;Log&nbsp;Out:&nbsp;No&nbsp;User&nbsp;Logged&nbsp;In"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cookie&nbsp;=&nbsp;"sid="<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;del&nbsp;sessions[self.user]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"Logged&nbsp;Out"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;generate_sid(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"".join(str(randint(1,9))&nbsp;for&nbsp;_&nbsp;in&nbsp;range(100))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;parse_cookies(self,&nbsp;cookie_list):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dict(((c.split("="))&nbsp;for&nbsp;c&nbsp;in&nbsp;cookie_list.split(";")))&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cookie_list&nbsp;else&nbsp;{}<br><br>address&nbsp;=&nbsp;('',&nbsp;8000)<br>handler&nbsp;=&nbsp;SessionHandler<br>server&nbsp;=&nbsp;HTTPServer(address,&nbsp;handler)<br><br>server.serve_forever()<br></div><p>Please read more about cookies, their expiration setting, and elements of session security before deploying anything like this. There are many more standard practices to consider; including encrypting the session id. Stay Safe!</p></p></p></p></p></p></p></p></blank>
                </div>
                <strong>Post By <a href="/"> David Gorski</a> on 2018/10/30 14:40:27</strong>
            </div>
        </body>
    </html>
