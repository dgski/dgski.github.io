
    <!doctype html>
    <html>
        <head>
            <title> Using C++17 to Create Composable, Recursive Data Types</title>
            <link rel="stylesheet" type="text/css" href="/style.css">
            
            <meta name="title" content=" Using C++17 to Create Composable, Recursive Data Types">
            <meta name="description" content=" An Easy-To-Use Tree Data Structure in 12 Lines">
            <meta property="og:type" content="website">
            <meta property="og:title" content=" Using C++17 to Create Composable, Recursive Data Types">
	        <meta property="twitter:title" content=" Using C++17 to Create Composable, Recursive Data Types">
        </head>
        <body>
            <div class="post-content">
                <a style="color:lightgrey" href="/">By David Gorski</a>
                <h1 class="post-title"> Using C++17 to Create Composable, Recursive Data Types</h1>
                <em> An Easy-To-Use Tree Data Structure in 12 Lines</em>
                <div class="post-body">
                    <blank><p>Sometimes it may be useful to dynamically generate portions of schemas and/or corresponding data, 'on-the-fly'. This can save you from having to pull a full library or schema file. Since most schemas philosophically resemble trees, the ability to generate tree data structures is the central element to fulfill this requirement. There are many other uses for such functionality; anything concerned with the realm of tree-like data structure operations.</p><p>This article presents a simple way to cleanly define nested, multi-branch type hierarchies using C++17. An endeavour which was much messier in older versions of C++. This can be altered and modified to generated pure schemas, new data types, and anything tree based. It leverages <a href='https://en.cppreference.com/w/cpp/utility/variant' >std::variant</a> to cleanly express a cohesive approach to designing easily composed data structures.</p><p>The final result will allow us to easily define N-Arity tree instances with clear, nested object instance declaration. For example:</p><div class='code' >auto&nbsp;root&nbsp;=<br>&nbsp;&nbsp;&nbsp;&nbsp;Node("addUserRequest",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("userId",&nbsp;123),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("name",&nbsp;"Charles"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("age",&nbsp;424),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("sessionInfo",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("signOnId",&nbsp;"f1f133112"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("bannerId",&nbsp;Null())}))}));<br></div><h2>Declaring Our Building Blocks</h2><p>In order to get started, we need to declare the fundamental types that will allows to construct this tree system. These will include our 'simple', scalar data types which hold concrete data on each node: int, string, null. As well as our 'complex', composite data types: an ordered sequence and a <a href='https://en.cppreference.com/w/cpp/utility/variant' >variant</a> representing the alternative data types each node can hold.</p><div class='code' >//&nbsp;Forward&nbsp;Declaration&nbsp;of&nbsp;Tree&nbsp;Node<br>struct&nbsp;Node;<br><br>//&nbsp;Simple&nbsp;<br>using&nbsp;Int&nbsp;=&nbsp;int;<br>using&nbsp;String&nbsp;=&nbsp;std::string;<br>using&nbsp;Null&nbsp;=&nbsp;std::monostate;<br><br>//&nbsp;Composite<br>using&nbsp;Sequence&nbsp;=&nbsp;std::vector&lt;Node&gt;;<br>using&nbsp;Data&nbsp;=&nbsp;std::variant&lt;Int,&nbsp;String,&nbsp;Null,&nbsp;Sequence&gt;;<br></div><p>With these type declarations out of the way, our data hierarchy is starting to take shape. Some explanations:</p><ul><li>We forward declare our <b>Node</b> class, so that the Sequence type can be aware of it.</li><li>We create aliases for Int, String and Null.</li><li>We declare an alias for the Sequence type: a vector of Nodes. </li><li>Finally, we declare the <b>Data</b> class. Each <b>Node</b> element will use a data member to hold either an Int, String, Null, or a Sequence of other Nodes.</li></ul><h2>The Nodes Class</h2><p>Now let's define the Node data type: </p><div class='code' >struct&nbsp;Node&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;m_name;<br>&nbsp;&nbsp;&nbsp;&nbsp;Data&nbsp;m_data;<br>&nbsp;&nbsp;&nbsp;&nbsp;explicit&nbsp;Node(std::string&&&nbsp;name,&nbsp;Data&&&nbsp;data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;m_name(std::move(name)),&nbsp;m_data(std::move(data))&nbsp;{}<br>};<br></div><p>The above definition has two member variables:</p><ul><li><b>m_name</b>: A string used to name the node's 'field'.</li><li><b>m_data</b>: The data the node is holding. Defined as a variant above.</li></ul><p>It also has a single explicit constructor which takes the node name and the data it holds as <a href='https://www.learncpp.com/cpp-tutorial/rvalue-references/' >R-value references</a>. Which means data will moved from the incoming instances if possible. If you plan to use this with variables or make copies, more constructors will have to be defined.</p><p>Surprisingly, that's it! Really. We can already build trees using the syntax demonstrated at the top of the article. Allowing us to develop nested hierarchies dynamically (but with type safety). Notice how the variant constructor accepts each type as needed to initialize the data member.</p><div class='code' >auto&nbsp;root&nbsp;=<br>&nbsp;&nbsp;&nbsp;&nbsp;Node("data",&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("users",&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("david",&nbsp;12322),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("charles",&nbsp;2322),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("rebecca",&nbsp;998)})),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("citySize",&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("nyc",&nbsp;8),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("toronto",&nbsp;4)}))}));<br><br></div><h2>Traversing The Structure</h2><p>Of course, with no way to traverse the structure, it's useless. Let's define output stream operators so that we can 'serialize' the data structure to <b>stdout</b>.</p><p>First let's do an overload for the <b>Null</b> type:</p><div class='code' >template&lt;typename&nbsp;Stream&gt;<br>Stream&&nbsp;operator&lt;&lt;(Stream&&nbsp;stream,&nbsp;const&nbsp;Null&&nbsp;null)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;stream&nbsp;&lt;&lt;&nbsp;"null";<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stream;<br>}<br></div><p>Very simple. Next let's overload it for the <b>Data</b> (variant) type:</p><div class='code' >template&lt;typename&nbsp;Stream&gt;<br>Stream&&nbsp;operator&lt;&lt;(Stream&&nbsp;stream,&nbsp;const&nbsp;Data&&nbsp;data)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::visit([&](auto&&nbsp;val)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream&nbsp;&lt;&lt;&nbsp;val;<br>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;data);<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stream;<br>}<br></div><p>Here, we are using <a href='https://en.cppreference.com/w/cpp/utility/variant/visit' >std::visit</a> to access the variant as it's current type. Using an auto template lambda keeps things concise. Inside, we simply apply the stream out operator to whatever is in the variant at the time (Int, Null, etc..).</p><p>Next, we can overload the stream operator for the <b>Node</b> type. Again, this definition is simple:</p><div class='code' >template&lt;typename&nbsp;Stream&gt;<br>Stream&&nbsp;operator&lt;&lt;(Stream&&nbsp;stream,&nbsp;const&nbsp;Node&&nbsp;node)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;"Node{&nbsp;name='"&nbsp;&lt;&lt;&nbsp;node.m_name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;"'&nbsp;data="&nbsp;&lt;&lt;&nbsp;node.m_data&nbsp;&lt;&lt;&nbsp;"&nbsp;}";<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stream;<br>}<br></div><p>So far, so good! However, we are missing the crucial overload for <b>Sequence</b> (std::vector). Why is this so important? It is what enables the actual traversing to deeper levels. Look carefully:</p><div class='code' >template&lt;typename&nbsp;Stream&gt;<br>Stream&&nbsp;operator&lt;&lt;(Stream&&nbsp;stream,&nbsp;const&nbsp;Sequence&&nbsp;data)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Sequence[&nbsp;";<br>&nbsp;&nbsp;&nbsp;&nbsp;for(const&nbsp;auto&&nbsp;d&nbsp;:&nbsp;data)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;d&nbsp;&lt;&lt;&nbsp;'&nbsp;';<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;']';<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stream;<br>}<br></div><p>For each child Node in the sequence we use the stream out operator. And this prints out their value. What if a child node is a sequence? Well then the same operator will be called recursively as needed. Viola! We can serialize our data:</p><div class='code' >auto&nbsp;root2&nbsp;=<br>&nbsp;&nbsp;&nbsp;&nbsp;Node("test",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("name",&nbsp;"Herbert"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("age",&nbsp;55)}));<br><br>//&nbsp;prints&nbsp;out:<br>//&nbsp;Node{&nbsp;name='test'&nbsp;data=Sequence[&nbsp;Node{&nbsp;name='name'&nbsp;data=Herbert&nbsp;}&nbsp;Node{&nbsp;name='age'&nbsp;data=55&nbsp;}&nbsp;]&nbsp;}<br>std::cout&nbsp;&lt;&lt;&nbsp;root2&nbsp;&lt;&lt;&nbsp;std::endl;<br></div><h2>Programmatically Generating Structure Segments </h2><p>We have a pretty usable and extensible system already. However, what if we want to transform a vector of custom structs into a canonical <b>Sequence</b> in our simple tree data system? All we need to do is write a utility function that iterates over the vector to produce a sequence:</p><div class='code' >template&lt;typename&nbsp;T,&nbsp;typename&nbsp;Func&gt;<br>Sequence&nbsp;vecToSeq(const&nbsp;std::vector&lt;T&gt;&&nbsp;vec,&nbsp;Func&nbsp;func)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Sequence&nbsp;result;<br>&nbsp;&nbsp;&nbsp;&nbsp;for(const&nbsp;auto&&nbsp;v&nbsp;:&nbsp;vec)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(func(v));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;<br>}<br></div><p>Now, we can use this function with a custom function argument to define the structure that will be appended for each data member within the vector:</p><div class='code' >//&nbsp;Define&nbsp;custom&nbsp;type<br>struct&nbsp;Custom&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;id;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>};<br><br>//&nbsp;Create&nbsp;vector<br>std::vector&lt;Custom&gt;&nbsp;vec&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;{12,&nbsp;"Johnny"},&nbsp;{&nbsp;344,&nbsp;"Filber"},&nbsp;{999,&nbsp;"Jennifer"}<br>};<br><br>//&nbsp;Use&nbsp;lambda&nbsp;to&nbsp;process&nbsp;each&nbsp;item&nbsp;in&nbsp;vector&nbsp;and&nbsp;output&nbsp;reflecting&nbsp;Node&nbsp;data&nbsp;structure<br>auto&nbsp;root3&nbsp;=<br>&nbsp;&nbsp;&nbsp;&nbsp;Node("data",&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("customThings",&nbsp;vecToSeq(vec,&nbsp;[](const&nbsp;Custom&&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Node("custom",&nbsp;Sequence({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("id",&nbsp;c.id),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("name",&nbsp;c.name)}));&nbsp;})),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node("requestId",&nbsp;232324)}));<br></div><p>This idea can be expanded to create <b>toTree()</b> functions for different types. Perhaps as an exercise, one could generalize the <b>toTree()</b> function for all types to allow automatic conversion without direct function calls.</p><h2>Conclusion</h2><p>As you can see, Modern C++ really improves the ability to work with composable data types using utility types such as <a href='https://en.cppreference.com/w/cpp/utility/variant' >std::variant</a>. The example presented in this post, provides a simple blueprint for more specific systems. It can extended and modified to support different schema definitions, serialization, and validation. Maybe you want just types with no names? Or a schema with no concrete data? Hopefully this serves a good starting point to direct your thinking. If the curly braces bother you, you play around with template parameter packs. And if you can get by with exclusively compile time generation, maybe you can experiment with using tuples to store the sequences. Have fun!</p><p><a href='https://gist.github.com/dgski/d00303b4a8be2d3c109d7a97d77106a3' >Link to Complete Code Example</a></p></blank>
                </div>
                <strong>Post By <a href="/"> David Gorski</a> on 2021/03/21 16:22:00</strong>
                <div class="post-bottom">
                    <strong>Liked this article?</strong><br>
                    Subscribe via <a href="/posts/rss/index.xml">RSS</a> or <a href="https://twitter.com/thedavidgorski">Twitter</a>.
                </div>
            </div>
        </body>
    </html>
