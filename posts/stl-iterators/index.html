
    <!doctype html>
    <html>
        <head>
            <title> Creating Custom STL Compatible Iterators in C++</title>
            <link rel="stylesheet" type="text/css" href="/style.css">
        </head>
        <body>
            
            <div class="post-content">
                <h1 class="post-title"> Creating Custom STL Compatible Iterators in C++</h1>
                <em> A Practical Start to Writing Simple Iteration Classes</em>
                <div class="post-body">
                    <blank><h2>What is an Iterator?</h2><p>The <b>Iterator</b> is the abstraction at the heart of all Collection-related functionality within the C++ Standard Library. Most algorithms are defined in terms of iterators. What is an iterator exactly?</p><p>Fundamentally, an Iterator represents a point of iteration. A point of iteration describes:</p><ul><li>How to retrieve the value at the point</li><li>How the point of iteration can be incremented/decremented</li><li>How to compare it with other points of iteration</li></ul><p>For example: Conceptually, if you are 'iterating' over a <b>book's pages</b>, the point of iteration could describe the following rules:</p><ul><li>The value at the point of iteration can be retrieved by reading the current page.</li><li>The point of iteration can be incremented by turning the page forward.</li><li>You can compare the point of iteration with other points of iteration by looking at the page number.</li></ul><p><i>Take note how this book example does not describe how to 'decrement' the iteration. Philosophically speaking, using this description; you could only ever turn the pages forward, never back.</i></p><p>In C++, iterators are defined as objects with methods describing their rules.</p><h2>Creating a Custom Collection</h2><p>First, we are going to create a custom collection type compatible with <b>STL algorithm constructs</b> and <b>ranged for-loop</b>. At that level of abstraction all we need to provide is <b>begin()</b> and <b>end()</b> methods, and then we will be able to write code like this:</p><div class='code' >Collection&nbspcol;<br><br>for(auto&&nbspc&nbsp:&nbspcol)<br>&nbsp&nbsp&nbsp&nbspcout&nbsp<<&nbspc&nbsp<<&nbspendl;<br><br>std::transform(begin(col),&nbspend(col),&nbspbegin(col),&nbsp[](auto&&nbspi)<br>{<br>&nbsp&nbsp&nbsp&nbspreturn&nbspi&nbsp*&nbspi;<br>});<br></div><p>Our collection will be a simple wrapper class around a c-array. This is what <b>std::array</b> provides in the Standard Library. In reality, you will only write custom collections and iterators if you need very particular data structures satisfying very specific requirements. Here is our collection definition:</p><div class='code' >template<class&nbspT,&nbspint&nbspN><br>class&nbspCollection<br>{<br>&nbsp&nbsp&nbsp&nbspT&nbspdata[N]&nbsp=&nbsp{&nbsp0&nbsp};<br>public:<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&nbspbegin()<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspcol_iterator<T>(data);<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&nbspend()<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspcol_iterator<T>(data&nbsp+&nbspN);<br>&nbsp&nbsp&nbsp&nbsp}<br>};<br></div><p>We take type and size as template arguments, create an array of that type and size. We also define methods which return the iterators to the beginning and end of the collection, passing the pointers to the first element (data) and just past the last element (data + N) as arguments.</p><h2>The Iterator Itself</h2><p>Now that we have created a collection-type, we need to define the iterator for use with the <b>begin()</b> and <b>end()</b> methods. First, we declare our iterator class ahead of our collection class declaration (The class needs to be aware of the iterator's existence), and then we define the iterator below the collection definition:</p><div class='code' >template&nbsp<class&nbspT>&nbspclass&nbspcol_iterator;&nbsp//&nbspDeclaration<br><br>//&nbspCollection&nbspclass&nbspdefinition&nbsp&nbsphere&nbsp...<br><br>template&nbsp<class&nbspT><br>class&nbspcol_iterator&nbsp//&nbspDefinition<br>{<br>&nbsp&nbsp&nbsp&nbsp//&nbspIterator&nbspDefinition&nbspGoes&nbspHere<br>}<br></div><p>There a few things an iterator needs in order to be STL compatible. This also depends on the type of the iterator. The types of iterators are:</p><ul><li>Input Iterators</li><li>Output Iterators</li><li>Forward Iterator</li><li>Bidirectional Iterators</li><li>Random-Access Iterators</li></ul><p>Each of these have different requirements. For the sake of simplicity, we will be defining a <b>Forward Iterator</b> for our collection, which has less requirements. These are the requirements for <b>Forward Iterators</b>:</p><ol><li> <b>Iterator Characteristics</b> - Five member type definitions which describe the iterator type and datatypes that iterator is related to.</li><li> <b>Default Constructor</b> -  Ability to construct the iterator with no arguments</li><li> <b>Dereference Operator (<a href='' ></a>)</b> - to access the underlying data the iterator is "pointing" towards.</li><li> <b>Not-Equal Operator (!=)</b> - to know when iterators are not equal to one another</li><li> <b>Pre-Increment Operator (++)</b> - to increment the iterator.</li><li> <b>Post-Increment Operator (++)</b> - to create and return an incremented iterator.</li></ol><p>And that's it! If these elements are present in a class it is a valid iterator that can be used with STL algorithms. These members must be publically accessible.</p><p>Let's define our iterator in code:<div class='code' >#include&nbsp<iterator><br><br>template&nbsp<class&nbspT><br>class&nbspcol_iterator<br>{<br>&nbsp&nbsp&nbsp&nbspT*&nbspdata;<br>public:<br>&nbsp&nbsp&nbsp&nbspusing&nbspiterator_category&nbsp=&nbspstd::forward_iterator_tag;<br>&nbsp&nbsp&nbsp&nbspusing&nbspvalue_type&nbsp=&nbspT;<br>&nbsp&nbsp&nbsp&nbspusing&nbspdifference_type&nbsp=&nbspsize_t;<br>&nbsp&nbsp&nbsp&nbspusing&nbsppointer&nbsp=&nbspT*;<br>&nbsp&nbsp&nbsp&nbspusing&nbspreference&nbsp=&nbspT&;<br><br>&nbsp&nbsp&nbsp&nbspcol_iterator(){}<br>&nbsp&nbsp&nbsp&nbspcol_iterator(pointer&nbsp_data)&nbsp:&nbspdata(_data)&nbsp{}<br><br>&nbsp&nbsp&nbsp&nbsppointer&nbspdata()&nbsp{&nbspreturn&nbspdata;&nbsp}<br>&nbsp&nbsp&nbsp&nbspreference&nbspoperator*()&nbsp{&nbspreturn&nbsp*data;&nbsp}<br>&nbsp&nbsp&nbsp&nbspbool&nbspoperator!=(const&nbspcol_iterator&&nbspother)<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspdata&nbsp!=&nbspother.data();<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&&nbspoperator++()<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdata&nbsp+=&nbsp1;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp*this;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&nbspoperator++(int)<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspcol_iterator<T>(data&nbsp+&nbsp1);<br>&nbsp&nbsp&nbsp&nbsp}<br>};<br></div><p>As you can see we have defined all the required elements of a <b>Forward Iterator</b>. One thing to note is the member <b>iterator_category</b>. It uses the <b>std::forward_iterator_tag</b> from the standard library marking this iterator as a <b>Forward Iterator</b>. These tags are available in <b>< iterator ></b>.</p><p>Now our class should easily work with STL algorithms such as the following:<div class='code' >Collection<int,&nbsp5>&nbsptest;<br>std::fill(test.begin(),&nbsptest.end(),&nbsp10);<br></div><p>To get more familiar with iterators:</p><ul><li>Add constant iterators to your collection ( define <b>cend()</b> and <b>cbegin()</b>)</li><li>Read up on the different iterator types and their specific requirements</li><li>Implement different iterator types for you collection</li><li>Try creating a collection with a different underlying type. For example using a linked-list instead of c-array. The increment and decrement methods will be much different.</li></ul><h2>Complete Code Example</h2><div class='code' >#include&nbsp<iterator><br>#include&nbsp<iostream><br>#include&nbsp<algorithm><br><br>template&nbsp<class&nbspT>&nbspclass&nbspcol_iterator;<br><br>template<class&nbspT,&nbspint&nbspN><br>class&nbspCollection<br>{<br>&nbsp&nbsp&nbsp&nbspT&nbspdata[N]&nbsp=&nbsp{&nbsp0&nbsp};<br>public:<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&nbspbegin()<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspcol_iterator<T>(data);<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&nbspend()<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspcol_iterator<T>(data&nbsp+&nbspN);<br>&nbsp&nbsp&nbsp&nbsp}<br>};<br><br>template&nbsp<class&nbspT><br>class&nbspcol_iterator<br>{<br>public:<br>&nbsp&nbsp&nbsp&nbspT*&nbspdata;<br>&nbsp&nbsp&nbsp&nbspusing&nbspiterator_category&nbsp=&nbspstd::forward_iterator_tag;<br>&nbsp&nbsp&nbsp&nbspusing&nbspvalue_type&nbsp=&nbspT;<br>&nbsp&nbsp&nbsp&nbspusing&nbspdifference_type&nbsp=&nbspsize_t;<br>&nbsp&nbsp&nbsp&nbspusing&nbsppointer&nbsp=&nbspT*;<br>&nbsp&nbsp&nbsp&nbspusing&nbspreference&nbsp=&nbspT&;<br><br>&nbsp&nbsp&nbsp&nbspcol_iterator(){}<br>&nbsp&nbsp&nbsp&nbspcol_iterator(pointer&nbsp_data)&nbsp:&nbspdata(_data)&nbsp{}<br><br>&nbsp&nbsp&nbsp&nbspreference&nbspoperator*()&nbsp{&nbspreturn&nbsp*data;&nbsp}<br>&nbsp&nbsp&nbsp&nbspbool&nbspoperator!=(const&nbspcol_iterator&&nbspother)<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspdata&nbsp!=&nbspother.data;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&&nbspoperator++()<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdata&nbsp+=&nbsp1;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp*this;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbspcol_iterator<T>&nbspoperator++(int)<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspcol_iterator<T>(data&nbsp+&nbsp1);<br>&nbsp&nbsp&nbsp&nbsp}<br>};<br><br>int&nbspmain(void)<br>{<br>&nbsp&nbsp&nbsp&nbspCollection<int,10>&nbsptest;<br><br>&nbsp&nbsp&nbsp&nbspstd::fill(test.begin(),&nbsptest.end(),&nbsp2);<br><br>&nbsp&nbsp&nbsp&nbspstd::transform(test.begin(),&nbsptest.end(),&nbsptest.begin(),&nbsp[](int&nbspi)<br>&nbsp&nbsp&nbsp&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspi&nbsp*&nbspi;<br>&nbsp&nbsp&nbsp&nbsp});<br><br>&nbsp&nbsp&nbsp&nbspfor(auto&nbspt&nbsp:&nbsptest)<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstd::cout&nbsp<<&nbspt&nbsp<<&nbspstd::endl;<br>}&nbsp&nbsp&nbsp<br></div></p></p></blank>
                </div>
                <strong>Post By <a href="/"> David Gorski</a> on 2019/03/02 16:00:00</strong>
            </div>
        </body>
    </html>
