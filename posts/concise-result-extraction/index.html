
    <!doctype html>
    <html>
        <head>
            <title> Concise Result Extraction in Modern C++</title>
            <link rel="stylesheet" type="text/css" href="/style.css">
            
            <meta name="title" content=" Concise Result Extraction in Modern C++">
            <meta name="description" content=" Using Template Parameter Packs to Unpack Results and Consolidate Errors">
            <meta property="og:type" content="website">
            <meta property="og:title" content=" Concise Result Extraction in Modern C++">
	        <meta property="twitter:title" content=" Concise Result Extraction in Modern C++">
        </head>
        <body>
            <div class="post-content">
                <a style="color:lightgrey" href="/">By David Gorski</a>
                <h1 class="post-title"> Concise Result Extraction in Modern C++</h1>
                <em> Using Template Parameter Packs to Unpack Results and Consolidate Errors</em>
                <div class="post-body">
                    <blank><p>A popular idiom in <b>functional programming</b> is the use of <a href='https://en.wikipedia.org/wiki/Algebraic_data_type' >sum types</a> to express results or optional values. When a function returns, it either succeeded and we get the result, or it failed and we have an error on our hands. This is a pattern in Modern C++ as well, enabled by standard library types such as <a href='https://en.cppreference.com/w/cpp/utility/variant' >std::variant</a> and <a href='https://en.cppreference.com/w/cpp/utility/optional' >std::optional</a>. In this article we will explore how to improve the ergonomics of handling multiple results and potential error values.</p><h2>The 'Result' Type</h2><p>For the purpose of this example we will define a simple 'Result' type: a variant that is either an 'Error' or a templated Type:</p><div class='code' >struct&nbsp;Error&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;message;<br>&nbsp;&nbsp;&nbsp;&nbsp;Error(std::string&nbsp;_message)&nbsp;:&nbsp;message(std::move(_message))&nbsp;{}<br>};<br>template&lt;typename&nbsp;Type&gt;<br>using&nbsp;Result&nbsp;=&nbsp;std::variant&lt;Error,&nbsp;Type&gt;;<br></div><p>Now we can define functions that either succeed and return a specified type, or an Error object which holds a message:</p><div class='code' >Result&lt;int&gt;&nbsp;getCloudInteger(Cloud&&nbsp;cloud)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(!cloud.ok())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Error(cloud.get_error_message());<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cloud.get_int();<br>}<br></div><h2>Getting Results</h2><p>This a pretty neat and clear interface, however, as with many operations we may be performing multiple operations that may success or fail. This results in a growing amount of boilerplate in the business logic code. Even when using a overloaded + operator for combining errors:</p><div class='code' >auto&nbsp;res1&nbsp;=&nbsp;getCloudInteger(cloud1);<br>auto&nbsp;res2&nbsp;=&nbsp;getCloudInteger(cloud2);<br>auto&nbsp;res3&nbsp;=&nbsp;getCloudInteger(cloud3);<br>if(is_error(res1&nbsp;&&&nbsp;is_error(res2)&nbsp;&&&nbsp;is_error(res3))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(res1)&nbsp;+&nbsp;get_error(res2)&nbsp;+&nbsp;get_error(res3);<br>}&nbsp;else&nbsp;if(is_error(res1)&nbsp;&&&nbsp;is_error(res2))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(res1)&nbsp;+&nbsp;get_error(res2);<br>}&nbsp;else&nbsp;if(is_error(res1)&nbsp;&&&nbsp;is_error(res3))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(res1)&nbsp;+&nbsp;get_error(res3);<br>}&nbsp;else&nbsp;if(is_error(res1))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(res1);<br>}&nbsp;else&nbsp;if(is_error(res2))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(res2);<br>}&nbsp;else&nbsp;if(is_error(res3))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(res3);<br>}<br>auto&nbsp;val1&nbsp;=&nbsp;get_ok(res1);<br>auto&nbsp;val2&nbsp;=&nbsp;get_ok(res2);<br>auto&nbsp;val3&nbsp;=&nbsp;get_ok(res3);<br></div><p><i>Note: is_error, get_error and get_ok are simple utility functions wrapping std::get&lt;int&gt; and std::holds_alternative</i></p><p>As the number of results we are processing increases, more and more lines of code are to be added. Obviously, it is best to keep your business logic as clear and uncluttered from 'implementation-level' concerns are possible. So how can we do this better? Modern C++ gives us template parameter packs, which allows to type-safe, variable argument functions with derived return types. We will leverage them to iterate over all the results and consolidate any errors.</p><h2>Using Parameter Packs</h2><p>Parameter packs are often iterated via recursion (especially before C++17). So to start we will define two overloaded functions:</p><ul><li>One that takes only a distinct result type.</li><li>One that takes a distinct result type and a pack argument.</li></ul><div class='code' >template&lt;typename&nbsp;Type&gt;<br>auto&nbsp;get_all(Result&lt;Type&gt;&&nbsp;r)&nbsp;-&gt;&nbsp;?;<br><br>template&lt;typename&nbsp;Type,&nbsp;typename...&nbsp;Types&gt;<br>auto&nbsp;get_all(Result&lt;Type&gt;&&nbsp;r,&nbsp;Types&...&nbsp;rest)&nbsp;-&gt;&nbsp;?;<br></div><p>Now, we must determine a suitable return value interface for this operation. We can use our Result type, as it already provides a value or error paradigm. What should be the success type within the Result? Since we want this function to be used generically we don't want a class with named member types. And using a standard library container type (such as std::vector) would add unnecessary overhead. Using a <a href='https://en.cppreference.com/w/cpp/utility/tuple' >std::tuple</a> with the same result order as the provided pack is the best option. This also provides compatibility with very convenient syntax sugar such as <a href='https://en.cppreference.com/w/cpp/utility/tuple/tie' >std::tie</a> and <a href='https://en.cppreference.com/w/cpp/language/structured_binding' >C++17 structure bindings</a>.</p><p>Let define our single argument <b>get_all</b> function first:</p><div class='code' >template&lt;typename&nbsp;Type&gt;<br>auto&nbsp;get_all(Result&lt;Type&gt;&&nbsp;r)&nbsp;-&gt;&nbsp;Result&lt;std::tuple&lt;Type&gt;&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(is_error(r))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(r);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;std::make_tuple(get_ok(r));<br>}<br></div><p>This is one is easy. The return type is simply a Result of <b>std::tuple</b> composed of one value: the results success type. If the result contains an error we simple return that error. Otherwise we get the value, stuff it in a tuple and stuff that tuple in a Result.</p><p>The variable argument version is a little more tricky. We will have to leverage some Modern C++ to implement it properly. First we need to determine the return type for the signature. Again, the overarching type is the Result type. What is the success type? A tuple of all the success types of all the provided Result arguments. We need to extract that by feeding some tuple utility function faux calls to the <a href='https://en.cppreference.com/w/cpp/language/decltype' >decltype</a> specifier.</p><div class='code' >template&lt;typename&nbsp;Type,&nbsp;typename...&nbsp;Types&gt;<br>auto&nbsp;get_all(Result&lt;Type&gt;&&nbsp;r,&nbsp;Types&...&nbsp;rest)<br>-&gt;&nbsp;Result&lt;decltype(std::tuple_cat(std::make_tuple(get_ok(r)),&nbsp;get_ok(get_all(rest...))))&gt;<br></div><p>Whew! Quite a bit! Although, if you're used to C++, you will actually find that signature to be pretty clear. The <b>decltype</b> specifier simply "returns" the type of the expression it is provided. In this case we are saying:</p><ul><li><b>decltype</b>: Get me the type of this expression</li><li><b>std::tuple_cat</b>: Concatenate these tuples.</li><li><b>std::make_tuple</b>: Make a tuple with these arguments. We provide one argument: the success result of the provided first argument.</li><li><b>get_ok(get_all(res...))</b>: Get the success result of getting the combined result of all arguments except the first one (the return type of this function call is Result of std::tuple&lt;...&gt;)</li></ul><p>Here is final body:</p><div class='code' >template&lt;typename&nbsp;Type,&nbsp;typename...&nbsp;Types&gt;<br>auto&nbsp;get_all(Result&lt;Type&gt;&&nbsp;r,&nbsp;Types&...&nbsp;rest)<br>-&gt;&nbsp;Result&lt;decltype(std::tuple_cat(std::make_tuple(get_ok(r)),&nbsp;get_ok(get_all(rest...))))&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;restRes&nbsp;=&nbsp;get_all(rest...);<br>&nbsp;&nbsp;&nbsp;&nbsp;if(is_error(r)&nbsp;&&&nbsp;is_error(restRes))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(r)&nbsp;+&nbsp;get_error(restRes);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if(is_error(r))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(r);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if(is_error(restRes))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(restRes);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;std::tuple_cat(std::make_tuple(get_ok(r)),&nbsp;get_ok(restRes));<br>}<br></div><p>The function body is a lot simpler once we know what we are returning. First we recursively call get_all on the argument except the first one. Then we check their error status. If both are errors, we combine the errors using an overloaded + operator, if only the current result is an error we return that error, otherwise we return the consolidated error from the consecutive arguments. If there are no errors at all, we concatenate a tuple comprised of the first result and the tuple returned from the recursive call on the remaining arguments. Viola!</p><h2>Finale</h2><p>Now we can ergonomically and concisely extract results and check for errors:</p><div class='code' >auto&nbsp;res1&nbsp;=&nbsp;getCloudInteger(cloud1);<br>auto&nbsp;res2&nbsp;=&nbsp;getCloudInteger(cloud2);<br>auto&nbsp;res3&nbsp;=&nbsp;getCloudInteger(cloud3);<br>auto&nbsp;aggregate_res&nbsp;=&nbsp;get_all(res1,&nbsp;res2,&nbsp;res3);<br>if(is_error(aggregate_res))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(aggregate_res);<br>}<br>auto&nbsp;[val1,&nbsp;val2,&nbsp;val3]&nbsp;=&nbsp;get_ok(aggregate_res);<br></div><p>This can be further refined and modified to suit your needs. Perhaps you can use an R-Value Reference argument signature and eliminate the need for the temporary Result variables:</p><div class='code' >auto&nbsp;aggregate_res&nbsp;=&nbsp;get_all(<br>&nbsp;&nbsp;&nbsp;&nbsp;getCloudInteger(cloud1),&nbsp;getCloudInteger(cloud2),&nbsp;getCloudInteger(cloud3));<br>if(is_error(aggregate_res))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_error(aggregate_res);<br>}<br>auto&nbsp;[val1,&nbsp;val2,&nbsp;val3]&nbsp;=&nbsp;get_ok(aggregate_res);<br></div><p>Or, if you prefer exception-based error handling but are dealing with a functional interface, you can simply throw exceptions within a get_all wrapper, eliminating even more boilerplate:</p><div class='code' >auto&nbsp;[val1,&nbsp;val2,&nbsp;val3]&nbsp;=&nbsp;get_all_vals(<br>&nbsp;&nbsp;&nbsp;&nbsp;getCloudInteger(cloud1),&nbsp;getCloudInteger(cloud2),&nbsp;getCloudInteger(cloud3)<br></div><p>Modern C++ Parameter Packs and error handling allow for cleaner call sites around your business logic. Writing a simple helper function like this is not difficult and can reduce the number of lines of code while allowing you to express your ideas and control flow more cleanly. This is especially useful for <b>std::async and std::future</b> and other libraries like it.</p><p><a href='https://gist.github.com/dgski/df5d7dcfc77031f79675f3b50565a051' >Link to Complete Code Example</a></p></blank>
                </div>
                <strong>Post By <a href="/"> David Gorski</a> on 2021/03/06 00:00:00</strong>
                <div class="post-bottom">
                    <strong>Liked this article?</strong><br>
                    Subscribe via <a href="/posts/rss/index.xml">RSS</a> or <a href="https://twitter.com/thedavidgorski">Twitter</a>
                </div>
            </div>
        </body>
    </html>
