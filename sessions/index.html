<html>
    <head>
        <title> Cookie-based Session Management</title>
        <link rel="stylesheet" type="text/css" href="/style.css">
    </head>
    <body>
        
        <div class="post-content">
            <h1 class="post-title"> Cookie-based Session Management</h1>
            <em> The Bare Necessities of Authentication and Recording User Status</em>
            <div class="post-body">
                <blank><p>Web frameworks had held my hand. Which for a beginner was great, but a lot of the fundamental aspects of back-end development had been abstracted from me, and I found annoying discrepancies between my knowledge and know-how. Sessions were one element I had neglected. I had taken them for granted; somehow magically some level of state is maintained between the server and the client.</p><p>It wasn't till I started writing my <a href='' >News Aggregator</a> Project in <a href='' >Racket</a> that I realized I don't really know how sessions work. Racket's a great language, but it's not exactly popular and doesn't have any web frameworks. I needed to learn and write my own session manager. So I did.</p><p>How exactly does the server know whether a given client is logged in? Turns out it's mainly about <b>cookies</b>. Cookies are small collections of data that the server asks the client to store. They are transmitted in the HTTP request headers under the <b>Cookie</b> section, and held by the browser on the client's end. </p><p>For sessions, the server generates a session id, tells the client to remember it, the client does so and attaches that sid to following requests, so the server knows whether a request belongs to an authenticated session or not.</p><p>To better understand how this works; let's write a simple HTTP request handler. We will use the basic web server provided in python's <b>http.server</b> package. </p><p>We will start with three elements:</p><ul><li>address: this is the address and port at which the server will listen for connections</li><li>handler: this is a class which has the necessary methods to handle requests</li><li>server: we will initialize the built-in <b>HTTPServer</b> object with our address and handler.</li></ul><p>Finally, we will start our server using the <b>serve_forever()</b> method:</p><div class='code' >from&nbsphttp.server&nbspimport&nbsp*<br><br>#Setup<br>address&nbsp=&nbsp('',&nbsp8000)<br>handler&nbsp=&nbspBaseHTTPRequestHandler<br>server&nbsp=&nbspHTTPServer(address,&nbsphandler)<br><br>#Start<br>server.serve_forever()<br></div><p>We can send a request to our new server using a browser at <b>localhost:8000</b>. However, we should still the following error:</p><div class='code' >Error&nbspresponse<br><br>Error&nbspcode:&nbsp501<br><br>Message:&nbspUnsupported&nbspmethod&nbsp('GET').<br><br>Error&nbspcode&nbspexplanation:&nbspHTTPStatus.NOT_IMPLEMENTED&nbsp-<br>Server&nbspdoes&nbspnot&nbspsupport&nbspthis&nbspoperation.<br></div><p>Looks like our handler can't handle simple <b>GET</b> requests... We need to do something about that. Define a new class at the top of the file. We still use <b>BaseHTTPRequestHandler</b> as the parent class, but add the <b>do_GET()</b> method:</p><div class='code' ><br>class&nbspSessionHandler(BaseHTTPRequestHandler):<br>&nbsp&nbsp&nbsp&nbspdef&nbspdo_GET(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.response&nbsp=&nbsp200<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.send_header('Content-type','text/html')<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcontent&nbsp=&nbsp"Hello"<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.wfile.write(bytes(content,&nbsp"utf-8"))<br><br></div><p>Remember to change the handler to our new class:</p><div class='code' >handler&nbsp=&nbspSessionHandler<br></div><h2>Dispatching</h2><p>Now if you visit again with your browser, you should now see the raw text, "Hello" displayed. That's a good start, but we need our server to do different things based on different URL paths. Let's add a simple dispatcher and methods to handle the paths:</p><div class='code' >class&nbspSessionHandler(BaseHTTPRequestHandler):<br>&nbsp&nbsp&nbsp&nbspdef&nbspdo_GET(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsproutes&nbsp=&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp"/login":&nbsp&nbsp&nbspself.login,<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp"/logout":&nbsp&nbspself.logout,<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp"/":&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.home<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsptry:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspresponse&nbsp=&nbsp200<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcontent&nbsp=&nbsproutes[self.path]()<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspexcept:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspresponse&nbsp=&nbsp404<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcontent&nbsp=&nbsp"Not&nbspFound"<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.send_response(response)<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.send_header('Content-type','text/html')<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.end_headers()<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.wfile.write(bytes(content,&nbsp"utf-8"))<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn<br>&nbsp&nbsp&nbsp&nbsp<br>&nbsp&nbsp&nbsp&nbspdef&nbsphome(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Welcome&nbspHome"<br><br>&nbsp&nbsp&nbsp&nbspdef&nbsplogin(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp#&nbsptodo:&nbspperform&nbsplogin<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Logged&nbspIn"<br><br>&nbsp&nbsp&nbsp&nbspdef&nbsplogout(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp#&nbsptodo:&nbspperform&nbsplogout<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Logged&nbspOut"<br></div><p>Okay, things are taking shape. Let's run through what was added:</p><ul><li>The <b>routes</b> dictionary has paths as keys and page methods as values.</li><li>We use the <b>try,except</b> statement to try to access the methods using the path. If it works, we set <b>response</b> to 200 (success) and prepare our content. Otherwise, we set <b>response</b> to 404 (not found) and set content to <b>Not Found</b>.</li><li>The home, login and logout methods return a text string representing themselves.</li></ul><h2>Logging In</h2><p>Now let's implement our login process. After a user logs in, the time spent logged in is referred to as a <b>session</b>. For each login and consecutive logout, we will have a unique session id (sid). So obviously, our next immediate step is to generate a new <b>sid</b> when the user clicks on login. We will use a dictionary to store our sessions ids. Usually a database fulfills this role, but for our simple purposes, this should be enough. For incredibly basic security import the randint function:</p><div class='code' >from&nbsprandom&nbspimport&nbsprandint<br></div><p>Add the following method to generate the sid:</p><div class='code' >def&nbspgenerate_sid(self):<br>&nbsp&nbsp&nbsp&nbspreturn&nbsp"".join(str(randint(1,9))&nbspfor&nbsp_&nbspin&nbsprange(100))<br></div><p>Add a global dictionary to the top of the file:</p><div class='code' >sessions&nbsp=&nbsp{}<br></div><p>Make the following changes to the <b>login</b> method:<div class='code' >def&nbsplogin(self):<br>&nbsp&nbsp&nbsp&nbsp#&nbspPassword&nbspnormally&nbspbe&nbspchecked&nbsphere<br>&nbsp&nbsp&nbsp&nbspsid&nbsp=&nbspself.generate_sid()<br>&nbsp&nbsp&nbsp&nbspself.cookie&nbsp=&nbsp"sid={}".format(sid)<br>&nbsp&nbsp&nbsp&nbspsessions[sid]&nbsp=&nbsp{"username",&nbsp"useragent","ip&nbspaddress","expiry"}<br>&nbsp&nbsp&nbsp&nbspreturn&nbsp"Logged&nbspIn"<br></div><p>Add the following <b>send_header</b> function calls to bottom of the <b>do_GET</b> method:<div class='code' >def&nbspdo_GET(self):&nbsp<br>&nbsp&nbsp&nbsp&nbsp#...<br>&nbsp&nbsp&nbsp&nbspself.cookie&nbsp=&nbspNone&nbsp#&nbspAddition<br>&nbsp&nbsp&nbsp&nbspself.send_response(response)<br>&nbsp&nbsp&nbsp&nbspself.send_header('Content-type','text/html')<br>&nbsp&nbsp&nbsp&nbspif&nbspself.cookie:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.send_header('Set-Cookie',&nbspself.cookie)&nbsp#&nbspAddition<br>&nbsp&nbsp&nbsp&nbspself.end_headers()<br>&nbsp&nbsp&nbsp&nbspself.wfile.write(bytes(content,&nbsp"utf-8"))<br>&nbsp&nbsp&nbsp&nbspreturn<br></div><p>What is happening should be clear: <b>login()</b> is setting the <b>self.cookie</b> member variable to a random string of numbers, and <b>self.send_header('Set-Cookie', self.cookie)</b> is sending it off as a cookie value. Now if you visit <b>/login</b> in your browser, and open up the web inspector, you should see <b>sid</b> as a cookie, with the value as whatever you generated. This cookie is held by the browser, and will be forwarded to our server with every request. It provides 'context' between requests.</p><p>Also, notice that <b>login()</b> adds the sid to the dictionary as a key with a dummy dictionary <b>{"username", "useragent","ip address","expiry"}</b> as a value. This is where a complete session manager would store those pieces of information about the user, to later verify the session. Add this on your own.</p><h2>Validating users</h2><p>Now we need to perform the most fundamental aspect of session management: validating a session. Let's say there is some content that only registered, logged in users can see. We don't want our user to have to provide their password with each page request; That would be incredibly cumbersome. We need to check if a request contains a session and display the right thing. We need to extract a header's sid to get that information. Add the following method to our <b>SessionHandler</b> class:</p><div class='code' >def&nbspparse_cookies(self,&nbspcookie_list):<br>&nbsp&nbsp&nbsp&nbspreturn&nbspdict(((c.split("="))&nbspfor&nbspc&nbspin&nbspcookie_list.split(";")))&nbspif&nbspcookie_list&nbspelse&nbsp{}<br></div><p>This will nicely extract the cookies string from the request and put it into a dictionary for our convenience. Also alter our <b>do_GET</b> <b>try</b> block so it looks like this:</p><div class='code' >try:<br>&nbsp&nbsp&nbsp&nbspresponse&nbsp=&nbsp200<br>&nbsp&nbsp&nbsp&nbspcookies&nbsp=&nbspself.parse_cookies(self.headers["Cookie"])<br>&nbsp&nbsp&nbsp&nbspif&nbsp"sid"&nbspin&nbspcookies:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.user&nbsp=&nbspcookies["sid"]&nbspif&nbsp(cookies["sid"]&nbspin&nbspsessions)&nbspelse&nbspFalse<br>&nbsp&nbsp&nbsp&nbspelse:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.user&nbsp=&nbspFalse<br>&nbsp&nbsp&nbsp&nbspcontent&nbsp=&nbsproutes[self.path]()<br></div><p>Our home page should display whether a user is currently logged in:<div class='code' >def&nbsphome(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Welcome&nbspUser!"&nbspif&nbspself.user&nbspelse&nbsp"Welcome&nbspStranger!"<br></div><p>What is happening here? Take a closer look at the try block. There are a few interesting things happening within:</p><ul><li>As before, we are setting the response to code 200, which for a HTTP request, it means that the page was found</li><li>Secondly, we are parsing the <b>Cookie</b> section of the header. Our <b>parse_cookies</b> method splits the Cookie string by ";" to seperate the individual cookies, then it puts the cookie ids and their values into a dictionary. If there are no cookies, it responds with an empty dictionary</li><li>Next, our try block checks if "sid" is in the <b>cookies</b> dictionary. If it isn't, it sets <b>self.user</b> to false. Otherwise, it then checks whether the sid value stored in the <b>sessions</b> global.</li><li>From then on, it's business as usual.</li></ul><p>We have altered a fundamental behaviour of our micro-program: when we visit the homepage without a generated sid cookie being broadcast by the browser we will see:<div class='code' >"Welcome&nbspStranger!"<br></div><p>Clearly, unless the sid is stored in the <b>sessions</b> dictionary, the application instance does not recognize the web user. But if the user logs in using the rudimentary <b>/login</b> page, it will display:<div class='code' >"Welcome&nbspUser!"<br></div><p>Try logging in, and then restarting our server. If you return to the home page, it won't recognize you, even if the browser holds and sends a <b>sid</b> cookie. Because the dictionary dies with the process, our server completely forgets about the session. If you visit the <b>login</b> page again, a new <b>sid</b> is generated, and we get <b>"Welcome User!"</b>.</p><p>To Recap: the login process generates a new sid, saves the users information(user agent, ip address, etc), and sends back a header asking for the user's browser to remember the new sid. Of course to be useful in most cases,  you would have to validate a login password before generating the sid and continuing, but the fundamental aspects of session management are already present.</p><h2>Logging Out</h2><p>What if the user wants to end their session? Well, we should probably give them a log out page as well. Let's add something to our currently useless logout page:<div class='code' >&nbsp&nbsp&nbsp&nbspdef&nbsplogout(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif&nbspnot&nbspself.user:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Can't&nbspLog&nbspOut:&nbspNo&nbspUser&nbspLogged&nbspIn"<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.cookie&nbsp=&nbsp"sid="<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdel&nbspsessions[self.user]<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Logged&nbspOut"<br></div><p>This method will check if a valid user is logged in, set the cookie to empty and delete the session id from the <b>sessions</b> dictionary, before returning the <b>"Logged Out"</b> text.</p><p>Check out what happens now: restart our your server application, open it and validate the following happens in order:</p><ol><li> On First Visit of the home page <b>"/"</b> it should display: "Welcome Stranger!".</li><li> If you now visit <b>"/login"</b>, it should display "Logged In", check your cookies for the "/" domain, you should see an <b>sid</b> cookie with the newly generated session.</li><li> Now if you visit the home page, your should see: "Welcome User!". Congratulations, your session has been validated!</li><li> Next test if the <b>"/logout"</b> page works. Visit it, it should say "Logged Out". Make sure it worked by once again checking your cookies in your browser. The <b>sid</b> cookie should be empty.</li><li> If you visit the home page again, it should display: "Welcome Stranger!". You have successfully logged out.</li></ol><p>The complete code should now look like:<div class='code' >from&nbsphttp.server&nbspimport&nbsp*<br>from&nbsprandom&nbspimport&nbsprandint<br><br>sessions&nbsp=&nbsp{}<br><br>class&nbspSessionHandler(BaseHTTPRequestHandler):<br>&nbsp&nbsp&nbsp&nbspdef&nbspdo_GET(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsproutes&nbsp=&nbsp{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp"/login":&nbspself.login,<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp"/logout":&nbspself.logout,<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp"/":&nbspself.home<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.cookie&nbsp=&nbspNone<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsptry:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspresponse&nbsp=&nbsp200<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcookies&nbsp=&nbspself.parse_cookies(self.headers["Cookie"])<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif&nbsp"sid"&nbspin&nbspcookies:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.user&nbsp=&nbspcookies["sid"]&nbspif&nbsp(cookies["sid"]&nbspin&nbspsessions)&nbspelse&nbspFalse<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspelse:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.user&nbsp=&nbspFalse<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcontent&nbsp=&nbsproutes[self.path]()<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspexcept:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspresponse&nbsp=&nbsp404<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcontent&nbsp=&nbsp"Not&nbspFound"<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.send_response(response)<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.send_header('Content-type','text/html')<br><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif&nbspself.cookie:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.send_header('Set-Cookie',&nbspself.cookie)<br><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.end_headers()<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.wfile.write(bytes(content,&nbsp"utf-8"))<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn<br>&nbsp&nbsp&nbsp&nbsp<br>&nbsp&nbsp&nbsp&nbspdef&nbsphome(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Welcome&nbspUser!"&nbspif&nbspself.user&nbspelse&nbsp"Welcome&nbspStranger!"<br><br>&nbsp&nbsp&nbsp&nbspdef&nbsplogin(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp#&nbspPassword&nbspwould&nbspnormally&nbspbe&nbspchecked&nbsphere<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsid&nbsp=&nbspself.generate_sid()<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.cookie&nbsp=&nbsp"sid={}".format(sid)<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsessions[sid]&nbsp=&nbsp{"username",&nbsp"useragent","ip&nbspaddress","expiry"}<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Logged&nbspIn"<br><br>&nbsp&nbsp&nbsp&nbspdef&nbsplogout(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif&nbspnot&nbspself.user:<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Can't&nbspLog&nbspOut:&nbspNo&nbspUser&nbspLogged&nbspIn"<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspself.cookie&nbsp=&nbsp"sid="<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdel&nbspsessions[self.user]<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"Logged&nbspOut"<br><br>&nbsp&nbsp&nbsp&nbspdef&nbspgenerate_sid(self):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbsp"".join(str(randint(1,9))&nbspfor&nbsp_&nbspin&nbsprange(100))<br><br>&nbsp&nbsp&nbsp&nbspdef&nbspparse_cookies(self,&nbspcookie_list):<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn&nbspdict(((c.split("="))&nbspfor&nbspc&nbspin&nbspcookie_list.split(";")))&nbsp\<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif&nbspcookie_list&nbspelse&nbsp{}<br><br>address&nbsp=&nbsp('',&nbsp8000)<br>handler&nbsp=&nbspSessionHandler<br>server&nbsp=&nbspHTTPServer(address,&nbsphandler)<br><br>server.serve_forever()<br></div><p>Please read more about cookies, their expiration setting, and elements of session security before deploying anything like this. There are many more standard practices to consider; including encrypting the session id. Stay Safe!</p></p></p></p></p></p></p></p></blank>
            </div>
            <strong>Post By <a href="/">David Gorski</a> on  2018-10-16 14:40:27</strong>
        </div>
    </body>
</html>